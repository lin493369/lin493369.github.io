<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daizi</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lin493369.github.io/"/>
  <updated>2017-04-11T11:35:38.000Z</updated>
  <id>http://lin493369.github.io/</id>
  
  <author>
    <name>小袋子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>伪单例模式</title>
    <link href="http://lin493369.github.io/2017/04/10/iOS%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lin493369.github.io/2017/04/10/iOS单例模式最佳实践/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅探讨 iOS 中单例的适用场景.</p>
<p>如需单例教程及其定义作用的请访问：<a href="http://www.jianshu.com/p/5226bc8ed784" target="_blank" rel="external">http://www.jianshu.com/p/5226bc8ed784</a>。</p>
<p>最近在做项目的重构工作，翻看了一下源码，发现了各种历史遗留问题。其中随处可见的单例，产生了万物皆单例的现象（说好的万物皆对象呢？）。</p>
<p>在与前开发人员沟通后，对方坚持使用单例的原因如下：</p>
<ul>
<li>代码简洁，不需要声明属性以及创建新的实例对象，需要的时候就可以马上调用。</li>
<li>方便管理对象的生命周期，把对象的创建和销毁时机都掌握在开发人员手中，可以控制对象的销毁时机。</li>
<li>历史遗留，iOS 系统类中随处可见的单例，我们的前辈们也都是这么用的，那就这么干吧。</li>
</ul>
<p>第一点无法反驳，单例确实很好用，写起来有种欲仙欲死的快感。但是，不管副作用的话，毒品产生的快感大概比这更甚吧。作为一个有追求的程序猿，怎么能被普通的感官快感所诱惑，我们的目标是星辰大海好吗。</p>
<p>第二点无法直视，既然是单例为什么要手动销毁呢。这时候就有人说了，比如退出登录后，需要把账户的单例销毁。作为需要全局使用的对象，这样的需求确实无可厚非，那么如果这个单例对象只是在一个地方使用到了呢？需要特地建一个单例并手动去管理单例的释放时机吗？这还是单例吗，这是假单例吧。</p>
<h3 id="真单例"><a href="#真单例" class="headerlink" title="真单例"></a>真单例</h3><p>吐槽完毕。进入正题，单例作为一个变态的全局变量，首先看他的定义：</p>
<blockquote>
<p>保证一个类仅有一个实例,并提供一个访问它的全局访问点。</p>
</blockquote>
<p>那么他的使用场景很简单且很明确：</p>
<blockquote>
<ul>
<li><p>在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在 APP 开发中我们可能在任何地方都要使用用户的信息，那么可以在登录的时候就把用户信息存放在一个文件里面，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
</li>
<li><p>有的情况下，某个类可能只能有一个实例。比如说你写了一个类用来播放音乐，那么不管任何时候只能有一个该类的实例来播放声音。再比如，一台计算机上可以连好几个打印机，但是这个计算机上的打印程序只能有一个，这里就可以通过单例模式来避免两个打印任务同时输出到打印机中，即在整个的打印过程中我只有一个打印程序的实例。</p>
</li>
</ul>
</blockquote>
<p>综上所述，不遵守以上定义的单例都是伪单例，例如用户信息单例就是典型的伪单例。</p>
<h3 id="伪单例"><a href="#伪单例" class="headerlink" title="伪单例"></a>伪单例</h3><p>使用伪单例并没有什么错，我们不需要咬文爵字，只要有合适的应用场景，并承认自己是伪单例，我们也可以开开心心地使用它。</p>
<p>那么我们今天就来好好谈谈伪单例的正确使用姿势（不管是不是你创造的，既然接盘了你就要负责到底）。</p>
<p>首先本文中对伪单例的定义：</p>
<blockquote>
<p>需要管理生命周期，并且长时间不需要销毁的单例对象。</p>
</blockquote>
<p>即在单例对象的基础上，需要对其生命周期进行管理，并且在应用启动期间如没有特殊情况，会一直存活。</p>
<h4 id="伪单例的销毁"><a href="#伪单例的销毁" class="headerlink" title="伪单例的销毁"></a>伪单例的销毁</h4><p>伪单例的销毁要基于其创建的方式，常规的有两种：同步锁、GCD。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static InstanceSync *instance = nil;</div><div class="line">@implementation InstanceSync</div><div class="line">// 同步锁方式</div><div class="line">+(instancetype)shareInstance&#123;</div><div class="line">    @synchronized (self) &#123;</div><div class="line">       <span class="built_in"> if </span>(!instance) &#123;</div><div class="line">           <span class="built_in"> instance </span>= [[self alloc]init];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="built_in"> return </span>instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static InstanceSync *instance = nil;<span class="keyword"></span></div><div class="line">static dispatch_once_t onceToken;</div><div class="line">@implementation InstanceSync</div><div class="line">// GCD 方式</div><div class="line">+(instancetype)shareInstance&#123;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">       <span class="built_in"> instance </span>= [[self alloc]init];</div><div class="line">    &#125;);</div><div class="line">   <span class="built_in"> return </span>instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们使用同步锁的单例来试验一下，一般我们销毁一个对象是将其置为空，即可以释放，如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSLog(@<span class="string">"instanceSync : %@"</span>,[<span class="keyword">InstanceSync </span><span class="keyword">shareInstance]);</span></div><div class="line"><span class="keyword">InstanceSync </span>*<span class="keyword">instanceSync </span>= [<span class="keyword">InstanceSync </span><span class="keyword">shareInstance];</span></div><div class="line"><span class="keyword">instanceSync </span>= nil<span class="comment">;</span></div><div class="line">NSLog(@<span class="string">"instanceSync : %@"</span>,[<span class="keyword">InstanceSync </span><span class="keyword">shareInstance]);</span></div></pre></td></tr></table></figure>
<p>实际上，这样并不能销毁这个对象：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2017<span class="selector-tag">-04-10</span> 10<span class="selector-pseudo">:54</span><span class="selector-pseudo">:10.449</span> <span class="selector-tag">instanceSync</span> : &lt;<span class="selector-tag">InstanceSync</span>: 0<span class="selector-tag">x600000016ea0</span>&gt;</div><div class="line">2017<span class="selector-tag">-04-10</span> 10<span class="selector-pseudo">:54</span><span class="selector-pseudo">:10.449</span> <span class="selector-tag">instanceSync</span> : &lt;<span class="selector-tag">InstanceSync</span>: 0<span class="selector-tag">x600000016ea0</span>&gt;</div></pre></td></tr></table></figure>
<p>其实在常规单例的内部都有一个全局静态变量，我们需要对其置空才能释放该单例对象：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)destoryInstance&#123;</div><div class="line">   <span class="built_in"> instance </span>= nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)dealloc&#123;</div><div class="line">    NSLog(@<span class="string">"%@ occur"</span>,NSStringFromSelector(_cmd));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们再来尝试一下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSLog(@<span class="string">"instanceSync : %@"</span>,[<span class="keyword">InstanceSync </span><span class="keyword">shareInstance]);</span></div><div class="line"><span class="keyword">InstanceSync </span>*<span class="keyword">instanceSync </span>= [<span class="keyword">InstanceSync </span><span class="keyword">shareInstance];</span></div><div class="line">[<span class="keyword">instanceSync </span>destoryInstance]<span class="comment">;</span></div><div class="line">NSLog(@<span class="string">"instanceSync : %@"</span>,[<span class="keyword">InstanceSync </span><span class="keyword">shareInstance]);</span></div></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017-04-10</span> <span class="number">11:05:22.112</span>  instanceSync : &lt;InstanceSync: <span class="number">0</span>x<span class="number">608000200480</span>&gt;</div><div class="line"><span class="number">2017-04-10</span> <span class="number">11:05:22.112</span>  instanceSync : &lt;InstanceSync: <span class="number">0</span>x<span class="number">600000200430</span>&gt;</div><div class="line"><span class="number">2017-04-10</span> <span class="number">11</span>:<span class="number">05:24.366</span>  dealloc occur</div></pre></td></tr></table></figure>
<p>可以看到伪单例对象 <code>[InstanceSync shareInstance]</code> 并没有马上进入 <code>dealloc</code>,而是在打印完第二 log 后才进入 <code>dealloc</code>；因此这里需要注意：</p>
<blockquote>
<p>如果伪单例对象被外部变量所持有，那么在释放单例对象时，需要确保所有持有变量都被释放后，才可以进入单例的释放。因此不建议将单例赋值给外部变量，以免无法在预期内释放单例对象。</p>
</blockquote>
<p>此外再次调用 <code>[InstanceSync shareInstance]</code> 将会产生新的对象，这也是易于理解的，那么如果使用 GCD 的方式能否产生新的对象？</p>
<p>实际上，这就取决于你销毁对象的方式：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(void)destoryInstance&#123;</div><div class="line">   <span class="built_in"> instance </span>= nil; // 销毁静态全局变量</div><div class="line">    onceToken = nil; // 销毁 GCD onceToken</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果只销毁静态全局变量，那么调用该方法后，将不会产生新的对象：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017-04-10</span> <span class="number">11</span>:<span class="number">21:37.917</span>  instanceGCD : &lt;InstanceGCD: <span class="number">0</span>x600<span class="number">00000d700</span>&gt;</div><div class="line"><span class="number">2017-04-10</span> <span class="number">11</span>:<span class="number">21:37.918</span>  instanceGCD : (null)</div><div class="line"><span class="number">2017-04-10</span> <span class="number">11</span>:<span class="number">21:37.918</span>  dealloc occur</div></pre></td></tr></table></figure>
<p>如果销毁 GCD onceToken ，那么不论销毁静态全局变量，都会产生新的对象。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>实际上，本文讲述的是在明知是伪单例的情况下，如何正确地管理伪单例的生命周期，文中若有不实之处，希望大家提出宝贵的意见。</p>
]]></content>
    
    <summary type="html">
    
      实际上，本文讲述的是在明知是伪单例的情况下，如何正确地管理伪单例的生命周期，文中若有不实之处，希望大家提出宝贵的意见。
    
    </summary>
    
      <category term="Objective-C" scheme="http://lin493369.github.io/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://lin493369.github.io/tags/Objective-C/"/>
    
      <category term="单例" scheme="http://lin493369.github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10 添加推送功能注意点及问题汇总</title>
    <link href="http://lin493369.github.io/2016/09/22/iOS10%E6%B7%BB%E5%8A%A0%E6%8E%A8%E9%80%81%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://lin493369.github.io/2016/09/22/iOS10添加推送功能设置流程及注意点/</id>
    <published>2016-09-21T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于 iOS 9 升级到 iOS 10 推送功能不正常的问题，总结了一下要点，亲们可以根据以下步骤，逐步排查问题，也可以逐步实现 iOS 10 的推送功能。</p>
<p>1、在项目 target 中，打开<code>Capabilitie —&gt; Push Notifications</code>，并会自动在项目中生成 .entitlement 文件。（很多同学升级后，获取不到 deviceToken，大概率是由于没开这个选项）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/928928-0c0e9c11b9d9a9eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Capabilitie —&gt; Push Notifications
"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/928928-d9e5b390c8799506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成 .entitlement"></p>
<p>2、确保添加了 <code>UserNotifications.framework</code>，并 import 到 <code>AppDelegate</code>，记得实现 <code>UNUserNotificationCenterDelegate</code> 。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>,<span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>3、在 <code>didFinishLaunchingWithOptions</code> 方法中，首先实现 <code>UNUserNotificationCenter</code> delegate，并使用 <code>UIUserNotificationSettings</code> 请求权限。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意，关于 iOS10 系统版本的判断，可以用下面这个宏来判断。不能再用截取字符的方法。</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GRATERTHAN_OR_EQUALTO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</span></div><div class="line"></div><div class="line">-(<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(SYSTEM_VERSION_GRATERTHAN_OR_EQUALTO(<span class="string">@"10.0"</span>))&#123;</div><div class="line">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</div><div class="line">    center.delegate = <span class="keyword">self</span>;</div><div class="line">    [center requestAuthorizationWithOptions:(UNAuthorizationOptionSound | UNAuthorizationOptionAlert | UNAuthorizationOptionBadge) completionHandler:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> * _Nullable error)&#123;</div><div class="line">         <span class="keyword">if</span>( !error )&#123;</div><div class="line">             [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotifications];</div><div class="line">         &#125;</div><div class="line">     &#125;];  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4、最后实现以下两个回调。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//====================For iOS 10====================</span></div><div class="line"></div><div class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">userNotificationCenter</span><span class="selector-pseudo">:(UNUserNotificationCenter</span> *)<span class="selector-tag">center</span> <span class="selector-tag">willPresentNotification</span><span class="selector-pseudo">:(UNNotification</span> *)<span class="selector-tag">notification</span> <span class="selector-tag">withCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(UNNotificationPresentationOptions options))<span class="selector-tag">completionHandler</span>&#123;</div><div class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"Userinfo %@"</span>,notification.request.content.userInfo);</div><div class="line"></div><div class="line"><span class="comment">//功能：可设置是否在应用内弹出通知</span></div><div class="line"><span class="selector-tag">completionHandler</span>(UNNotificationPresentationOptionAlert);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//点击推送消息后回调</span></div><div class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">userNotificationCenter</span><span class="selector-pseudo">:(UNUserNotificationCenter</span> *)<span class="selector-tag">center</span> <span class="selector-tag">didReceiveNotificationResponse</span><span class="selector-pseudo">:(UNNotificationResponse</span> *)<span class="selector-tag">response</span> <span class="selector-tag">withCompletionHandler</span><span class="selector-pseudo">:(void(</span>^)())<span class="selector-tag">completionHandler</span>&#123;</div><div class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"Userinfo %@"</span>,response.notification.request.content.userInfo);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：需要根据系统版本号来判断是否使用新的 <code>UserNotifications.framework</code>，因此，不要着急删除 iOS 10 以前的代码。</p>
<p>有问题，敬请留言探讨。</p>
]]></content>
    
    <summary type="html">
    
      很多童鞋从 iOS 9 升级到 iOS 10 后，发现推送功能有很多问题，特此总结.
    
    </summary>
    
      <category term="Notification" scheme="http://lin493369.github.io/categories/Notification/"/>
    
    
      <category term="iOS10" scheme="http://lin493369.github.io/tags/iOS10/"/>
    
      <category term="Notification" scheme="http://lin493369.github.io/tags/Notification/"/>
    
      <category term="推送" scheme="http://lin493369.github.io/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10 IDFA 新策略 </title>
    <link href="http://lin493369.github.io/2016/08/31/%E8%8E%B7%E5%8F%96IDFA%E8%BF%94%E5%9B%9E%E5%85%A8%E9%9B%B6%E9%94%99%E8%AF%AF/"/>
    <id>http://lin493369.github.io/2016/08/31/获取IDFA返回全零错误/</id>
    <published>2016-08-30T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多人将获取 IDFA 作为应用的唯一标识的替代方案，因此对 IDFA 有很大的需求。</p>
<p>但是最近很多同学在获取 IDFA 时发现返回：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">00000000</span><span class="number">-0000</span><span class="number">-0000</span><span class="number">-0000</span><span class="number">-000000000000</span></div></pre></td></tr></table></figure>
<p>很不幸，实际上是由于：这些设备升级到 iOS10，并且用户开启了限制广告跟踪。</p>
<p><img src="http://img.blog.csdn.net/20160831102842189" alt="这里写图片描述"></p>
<blockquote>
<p>在 iOS 10 之前：当用户开启限制广告跟踪，仍然可以将 IDFA 用于不同的用途，除了不能用于投放特定广告目标。</p>
</blockquote>
<p>但是，iOS 10 之后，对 IDFA 做了变更，参照官方文档所述：</p>
<blockquote>
<p>Important</p>
<p>In iOS 10.0 and later, the value of advertisingIdentifier is all zeroes when the user has limited ad tracking.</p>
<p>在 iOS 10.0 以后，当用户开启限制广告跟踪，advertisingIdentifier 的值将是全零。</p>
</blockquote>
<p>在这种情况下，如果你依然使用 IDFA 作为唯一标识符的话，可能会有大危机，推荐一个替代方案 <a href="https://github.com/ylechelle/OpenIDFA" target="_blank" rel="external">OpenIDFA</a>（一个基于可持续、隐私、友好的 identifier 方案）。</p>
<p>以上，有用到 IDFA 并且将其作为标识用户唯一手段的童鞋请悉知，虽是小改动，但对刚需开发者来说还是蛮严重的，特别 iOS 10 正式版放出之后，可能将是大灾难（危言耸听。。）。</p>
]]></content>
    
    <summary type="html">
    
      相信很多人将获取 IDFA 作为应用的唯一标识的替代方案，因此对 IDFA 有很大的需求。。
    
    </summary>
    
      <category term="iOS10" scheme="http://lin493369.github.io/categories/iOS10/"/>
    
    
      <category term="iOS10" scheme="http://lin493369.github.io/tags/iOS10/"/>
    
      <category term="IDFA" scheme="http://lin493369.github.io/tags/IDFA/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10 添加本地推送（Local Notification）</title>
    <link href="http://lin493369.github.io/2016/07/01/iOS10%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81%EF%BC%88LocalNotification)/"/>
    <id>http://lin493369.github.io/2016/07/01/iOS10添加本地推送（LocalNotification)/</id>
    <published>2016-06-30T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 10 中废弃了 <code>UILocalNotification</code>（ <code>UIKit Framework</code>） 这个类，采用了全新的 <code>UserNotifications Framework</code> 来推送通知，从此推送通知也有了自己的标签 <code>UN</code>（这待遇真是没别人了），以及对推送功能的一系列增强改进（两个 extension 和 界面的体验优化），简直是苹果的亲儿子，因此推送这部分功能也成为开发中的重点。</p>
<p>本文主要查看了 iOS 10 的相关文档，整理出了在 iOS 10 下的本地推送通知，由于都是代码，就不多做讲解，直接看代码及注释，有问题留言讨论哦。</p>
<hr>
<h2 id="新的推送注册机制"><a href="#新的推送注册机制" class="headerlink" title="新的推送注册机制"></a>新的推送注册机制</h2><p>注册通知（<code>Appdelegate.m</code>）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()&lt;<span class="title">UNUserNotificationCenterDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="comment">// 使用 UNUserNotificationCenter 来管理通知</span></div><div class="line">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</div><div class="line">    <span class="comment">//监听回调事件</span></div><div class="line">    center.delegate = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//iOS 10 使用以下方法注册，才能得到授权</span></div><div class="line">    [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert + UNAuthorizationOptionSound)</div><div class="line">                          completionHandler:^(<span class="built_in">BOOL</span> granted, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                              <span class="comment">// Enable or disable features based on authorization.</span></div><div class="line">                          &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//获取当前的通知设置，UNNotificationSettings 是只读对象，不能直接修改，只能通过以下方法获取</span></div><div class="line">    [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - UNUserNotificationCenterDelegate</span></div><div class="line"><span class="comment">//在展示通知前进行处理，即有机会在展示通知前再修改通知内容。</span></div><div class="line">-(<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(<span class="keyword">void</span> (^)(UNNotificationPresentationOptions))completionHandler&#123;</div><div class="line">    <span class="comment">//1. 处理通知</span></div><div class="line">    </div><div class="line">    <span class="comment">//2. 处理完成后条用 completionHandler ，用于指示在前台显示通知的形式</span></div><div class="line">    completionHandler(UNNotificationPresentationOptionAlert);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="推送本地通知"><a href="#推送本地通知" class="headerlink" title="推送本地通知"></a>推送本地通知</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用 UNNotification 本地通知</span></div><div class="line">+(<span class="keyword">void</span>)<span class="string">registerNotification:</span>(NSInteger )alerTime&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 使用 UNUserNotificationCenter 来管理通知</span></div><div class="line">    UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</div><div class="line">    </div><div class="line">    <span class="comment">//需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。</span></div><div class="line">    UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];</div><div class="line">    content.title = [NSString <span class="string">localizedUserNotificationStringForKey:</span>@<span class="string">"Hello!"</span> <span class="string">arguments:</span>nil];</div><div class="line">    content.body = [NSString <span class="string">localizedUserNotificationStringForKey:</span>@<span class="string">"Hello_message_body"</span></div><div class="line"><span class="symbol">                                                         arguments:</span>nil];</div><div class="line">    content.sound = [UNNotificationSound defaultSound];</div><div class="line">    </div><div class="line">    <span class="comment">// 在 alertTime 后推送本地推送</span></div><div class="line">    UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger</div><div class="line"><span class="symbol">                                                  triggerWithTimeInterval:</span>alerTime <span class="string">repeats:</span>NO];</div><div class="line"></div><div class="line">    UNNotificationRequest* request = [UNNotificationRequest <span class="string">requestWithIdentifier:</span>@<span class="string">"FiveSecond"</span></div><div class="line"><span class="symbol">                                                                          content:</span>content <span class="string">trigger:</span>trigger];</div><div class="line">    </div><div class="line">    <span class="comment">//添加推送成功后的处理！</span></div><div class="line">    [center <span class="string">addNotificationRequest:</span>request <span class="string">withCompletionHandler:</span>^(NSError * _Nullable error) &#123;</div><div class="line">        UIAlertController *alert = [UIAlertController <span class="string">alertControllerWithTitle:</span>@<span class="string">"本地通知"</span> <span class="string">message:</span>@<span class="string">"成功添加推送"</span> <span class="string">preferredStyle:</span>UIAlertControllerStyleAlert];</div><div class="line">        UIAlertAction *cancelAction = [UIAlertAction <span class="string">actionWithTitle:</span>@<span class="string">"取消"</span> <span class="string">style:</span>UIAlertActionStyleCancel <span class="string">handler:</span>nil];</div><div class="line">        [alert <span class="string">addAction:</span>cancelAction];</div><div class="line">        [[UIApplication sharedApplication].keyWindow.rootViewController <span class="string">presentViewController:</span>alert <span class="string">animated:</span>YES <span class="string">completion:</span>nil];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>iOS 10 以前本地推送通知：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)registerLocalNotificationInOldWay:(<span class="built_in">NSInteger</span>)alertTime &#123;</div><div class="line">    <span class="comment">// ios8后，需要添加这个注册，才能得到授权</span></div><div class="line">    <span class="comment">//    if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) &#123;</span></div><div class="line">    <span class="comment">//        UIUserNotificationType type =  UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound;</span></div><div class="line">    <span class="comment">//        UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:type</span></div><div class="line">    <span class="comment">//                                                                                 categories:nil];</span></div><div class="line">    <span class="comment">//        [[UIApplication sharedApplication] registerUserNotificationSettings:settings];</span></div><div class="line">    <span class="comment">//        // 通知重复提示的单位，可以是天、周、月</span></div><div class="line">    <span class="comment">//    &#125;</span></div><div class="line">    </div><div class="line">    <span class="built_in">UILocalNotification</span> *notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</div><div class="line">    <span class="comment">// 设置触发通知的时间</span></div><div class="line">    <span class="built_in">NSDate</span> *fireDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:alertTime];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"fireDate=%@"</span>,fireDate);</div><div class="line">    </div><div class="line">    notification.fireDate = fireDate;</div><div class="line">    <span class="comment">// 时区</span></div><div class="line">    notification.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</div><div class="line">    <span class="comment">// 设置重复的间隔</span></div><div class="line">    notification.repeatInterval = kCFCalendarUnitSecond;</div><div class="line">    </div><div class="line">    <span class="comment">// 通知内容</span></div><div class="line">    notification.alertBody =  <span class="string">@"该起床了..."</span>;</div><div class="line">    notification.applicationIconBadgeNumber = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 通知被触发时播放的声音</span></div><div class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</div><div class="line">    <span class="comment">// 通知参数</span></div><div class="line">    <span class="built_in">NSDictionary</span> *userDict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:<span class="string">@"开始学习iOS开发了"</span> forKey:<span class="string">@"key"</span>];</div><div class="line">    notification.userInfo = userDict;</div><div class="line">    </div><div class="line">    <span class="comment">// ios8后，需要添加这个注册，才能得到授权</span></div><div class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] respondsToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)]) &#123;</div><div class="line">        <span class="built_in">UIUserNotificationType</span> type =  <span class="built_in">UIUserNotificationTypeAlert</span> | <span class="built_in">UIUserNotificationTypeBadge</span> | <span class="built_in">UIUserNotificationTypeSound</span>;</div><div class="line">        <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:type</div><div class="line">                                                                                 categories:<span class="literal">nil</span>];</div><div class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:settings];</div><div class="line">        <span class="comment">// 通知重复提示的单位，可以是天、周、月</span></div><div class="line">        notification.repeatInterval = <span class="built_in">NSCalendarUnitDay</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 通知重复提示的单位，可以是天、周、月</span></div><div class="line">        notification.repeatInterval = <span class="built_in">NSDayCalendarUnit</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行通知注册</span></div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] scheduleLocalNotification:notification];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文主要查看了 iOS 10 的相关文档，整理出了在 iOS 10 下的本地推送通知.
    
    </summary>
    
      <category term="Notification" scheme="http://lin493369.github.io/categories/Notification/"/>
    
    
      <category term="iOS10" scheme="http://lin493369.github.io/tags/iOS10/"/>
    
      <category term="Notification" scheme="http://lin493369.github.io/tags/Notification/"/>
    
      <category term="推送" scheme="http://lin493369.github.io/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS 简单易懂的 Block 回调使用和解析 </title>
    <link href="http://lin493369.github.io/2016/03/11/iOS%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84Block%E5%9B%9E%E8%B0%83%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
    <id>http://lin493369.github.io/2016/03/11/iOS简单易懂的Block回调使用和解析/</id>
    <published>2016-03-10T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>老实说在早前我已经学会了如何使用 Block 来做一些方法回调，传递参数的功能，并且用 Block 简单封装了第三方的网络库（AFNetworking）。虽说对 Block 的应用说不上得心应手，但是却是极其地喜欢使用这种设计模式，并且在项目中也大量地使用了。</p>
<p>但是，最近一位即将参加面试的学弟问我，什么是 Block 呢？我蒙圈了，但是毕竟是学长，我假装淡定地反问道：你所理解的 Block 是什么呢？学弟说：是一段封装的代码块，并可以放在任意位置使用，还可以传递数据。我心里暗喜，这孩子还是图样了，于是语重心长地说：Block 的本质是可以截取自动变量的匿名函数。但是说出这句话我就后悔了，这句话他喵的到底是个什么意思？看着学弟满意地走了之后，我就疯狂地上网查资料，万一下次这个熊孩子深究起来可不就破坏了我英明神武的形象了，但是并没有很满意的答案，大多是照文档描述了 Block 的定义以及基本用法，不然就是高深地去探讨 Block 底层的实现机制，显然这些都不适合让一个初学者既能学会使用又能够没有疑惑地使用。</p>
<p>本文主要讲的是 <strong>Block 回调的使用</strong>，以及 <strong>Block 是如何实现这种神奇的回调</strong>两部分来讲的。</p>
<h2 id="Block-回调实现"><a href="#Block-回调实现" class="headerlink" title="Block 回调实现"></a>Block 回调实现</h2><p>不着急，先跟着我实现最简单的 Block 回调传参的使用，如果你能举一反三，基本上可以满足了 OC 中的开发需求。已经实现的同学可以跳到下一节。</p>
<p>首先解释一下我们例子要实现什么功能（其实是烂大街又最形象的例子）：<br>有两个视图控制器 A 和 B，现在点击 A 上的按钮跳转到视图 B ，并在 B 中的textfield 输入字符串，点击 B 中的跳转按钮跳转回 A ，并将之前输入的字符串<br>显示在 A 中的 label 上。也就是说 A 视图中需要回调 B 视图中的数据。</p>
<p>想不明白的同学可以看一看最终实现的效果图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/928928-80838951ad6524a9?imageMogr2/auto-orient/strip" alt="block example"></p>
<p>这里不再对 <a href="http://blog.csdn.net/totogo2010/article/details/7839061" target="_blank" rel="external">Block 的语法</a>做说明了，不了解的同学可以点<a href="http://blog.csdn.net/totogo2010/article/details/7839061" target="_blank" rel="external">传送门</a>。</p>
<p>首先，我们需要定义两个试图控制器 AViewController 和 BViewController，现在我们需要思考一下，Block 应该在哪里定义呢？</p>
<p>我们可以简单地这样思考，需要回调数据的是 A 视图，那么 Block 就应该在 B 中定义，用于获取传入回调数据。</p>
<p>因此我们在 BViewController.h 中定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BViewController.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^CallBackBlcok) (<span class="built_in">NSString</span> *text);<span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)CallBackBlcok callBackBlock;<span class="comment">//2</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，代码 1 用 typedef 定义了 <code>void(^) (NSString *text)</code>的别名为 <code>CallBackBlcok</code> 。这样我们就可以在代码 2 中，使用这个别名定义一个 Block 类型的变量 <code>callBackBlock</code>。</p>
<p>在定义了 <code>callBackBlock</code> 之后，我们可以在 B 中的点击事件中添加 <code>callBackBlock</code> 的传参操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BViewController.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)click:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="keyword">self</span>.callBackBlock(_textField.text); <span class="comment">//1</span></div><div class="line">    [<span class="keyword">self</span>.navigationController popToRootViewControllerAnimated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以在想要获取数据回调的地方，也就 A 的视图中调用 block：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AViewController.m</span></div><div class="line">- (<span class="keyword">IBAction</span>)push:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    BViewController *bVC = [<span class="keyword">self</span>.storyboard instantiateViewControllerWithIdentifier:<span class="string">@"BViewController"</span>];</div><div class="line">    </div><div class="line">    bVC.callBackBlock = ^(<span class="built_in">NSString</span> *text)&#123;   <span class="comment">// 1</span></div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"text is %@"</span>,text);</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.label.text = text;</div><div class="line">        </div><div class="line">    &#125;;</div><div class="line">    [<span class="keyword">self</span>.navigationController pushViewController:bVC animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码 1 中，通过对回调将 B 中的数据传递到代码块中，并赋值给 A<br>中的 label，实现了整个回调过程。</p>
<p>上例是通过将 block 直接赋值给 block 属性，也可以通过方法参数的方式传递 block 块。</p>
<p>由于考虑有的小伙伴翻墙比较困难，完整的示例代码放在 git.oschina.net 上，代码地址：<a href="http://git.oschina.net/xiaodaizi/BlockMagic" target="_blank" rel="external">BlockMagic</a> 。</p>
<h2 id="关于-Block-的疑惑"><a href="#关于-Block-的疑惑" class="headerlink" title="关于 Block 的疑惑"></a>关于 Block 的疑惑</h2><p>到目前为止，一切看起来都很美好（如果你照着上面的例子做的话），功能正常， A 视图中也获取到数据了。但是某些人可能就要说了，你的代码有问题，你的思路有问题，你这是误人子弟。</p>
<p>是的，代码的确还有问题，第一个问题就是循环引用的问题，在 A 视图的block 代码块中：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bVC.callBackBlock </span>= ^(NSString *text)&#123;</div><div class="line">       NSLog(@<span class="string">"text is %@"</span>,text)<span class="comment">;     </span></div><div class="line">       self.label<span class="meta">.text</span> = text<span class="comment">;      </span></div><div class="line">    &#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>代码 <code>self.label.text = text;</code> ，在 Block 中引用 self ，也就是 A ，而 A 创建并引用了 B ，而 B 引用 <code>callBackBlock</code>，此时就形成了一个循环引用，而编译器也不会报任何错误，我们需要非常小心这个问题（面试百分百问到我会乱说？）。此时我们通常的解决方法是使用弱引用来解除这个循环：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    __<span class="keyword">weak</span> <span class="built_in">AViewController</span> *weakSelf = <span class="keyword">self</span>;</div><div class="line">    bVC.callBackBlock = ^(<span class="built_in">NSString</span> *text)&#123; </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"text is %@"</span>,text);  </div><div class="line"><span class="comment">//        self.label.text = text;  </span></div><div class="line">        weakSelf.label.text = text;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>第二个问题是我自己对 Block 的理解不到位，我们都知道 Block 能截取自动变量，并且是不能在 Block 块中进行修改的（除非用<code>__block</code>修饰符），但是很明显 <code>weakSelf.label.text</code>的值被修改了，并且没有用<code>__block</code>修饰符， 这是为什么呢？因为 <code>label</code> 是个全局变量，而如果像如下的局部变量 <code>a</code> 是不能修改的，编译器也会报错：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/928928-13f64f2fd46f30fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="局部变量"></p>
<p>通过这个小例子发现的两个问题，也算是值得了。</p>
<h2 id="Block-为什么能实现神奇的回调"><a href="#Block-为什么能实现神奇的回调" class="headerlink" title="Block 为什么能实现神奇的回调"></a>Block 为什么能实现神奇的回调</h2><p>在这里我不会说什么实现原理，仅仅是个人对 Block 能实现神奇回调的理解，有错误的地方请大家指出。</p>
<p>在先前使用 Block 的过程中，虽然会使用，但是总是有一个疑惑，简单说来就是：</p>
<p>为什么在 A 中的 block 块能调用到 B 中的数据？</p>
<p>回顾一下我们在 B 中所实现的代码，不外乎定义了一个 Block 变量，并在适当的时候传入参数，那么为什么在调用了   <code>self.callBackBlock(_textField.text)</code> 之后，值就神奇传到了 A 中的 Block 块了呢？</p>
<p>通过整理使用的过程，我发现是我们的思维陷入了误区（可能是我个人），我们认为在 B 中传入 <code>_textField.text</code> 参数之后， A 中的 Block 块就可以获取到值。虽然思路是对的，但其实是不完整，导致我们形成了回调的数据是通过某种底层实现传递过去的错觉，这就使得我们认为这不需要深究。</p>
<p>事实是，通过简单的整理我们可以发现完整的回调流程应该是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/928928-e4de1ec1692eb173?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回调流程"></p>
<ol>
<li>block 代码块赋值给 <code>bVC.callBackBlock</code>，此时 <code>callBackBlock</code> 的指针就指向这个代码块。</li>
<li>调用 <code>callBackBlock(NSString *text)</code></li>
<li><p>由于 <code>callBackBlock</code> 的指针是指向 A 中的 block 代码块，因此执行代码块的代码，实现回调。</p>
<p>很显然之前我忽略了代码块赋值给 <code>callBackBlock</code> 的这个操作（羞愧）。</p>
<p>现在再通过一段代码可以更清晰地理解这个原理：</p>
</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> bVC.callBackBlock = ^(NSString *<span class="built_in">text</span>)&#123; <span class="comment">//1</span></div><div class="line">        NSLog(@<span class="string">"text is %@"</span>,<span class="built_in">text</span>);</div><div class="line">    &#125;;</div><div class="line">  bVC.callBackBlock = ^(NSString *<span class="built_in">text</span>)&#123; <span class="comment">//2</span></div><div class="line">        NSLog(@<span class="string">"text b is %@"</span>,<span class="built_in">text</span>);</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>上述代码中，我们对 <code>callBackBlock</code>进行了两次赋值，结果会怎么样呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/928928-2788415bb549621d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="two block"></p>
<p>可以看出来，Block 的回调只对代码 2 生效，因为<code>callBackBlock</code>的指针最后指向了代码 2 的代码块。所以并没有什么神奇的魔法，也没什么隐藏的底层机制（这里指的是方便理解的底层）让你可以带着疑惑去使用它。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我这个人学习方法，总结起来就是看到新技术，先在自己的代码里跑一遍，能跑通，并且使用起来没有什么难度，就基本不会深究了（如果遇到某个熊孩子就坑了）。但是自我反思过，这样的学习方法是很不对的，写代码不能不求甚解，如果想要有所突破，不想局限于码农，一定要深入探究一下实现的机制，最起码要保证不带着疑惑去使用。</p>
]]></content>
    
    <summary type="html">
    
      本文主要讲的是 Block 回调的使用，以及 Block 是如何实现这种神奇的回调两部分来讲的。
    
    </summary>
    
      <category term="Objective-C" scheme="http://lin493369.github.io/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://lin493369.github.io/tags/Objective-C/"/>
    
      <category term="block" scheme="http://lin493369.github.io/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>在 WordPress 中使用 Github README 标签</title>
    <link href="http://lin493369.github.io/2016/02/20/%E5%9C%A8WordPress%E4%B8%AD%E4%BD%BF%E7%94%A8GithubREADME%E6%A0%87%E7%AD%BE/"/>
    <id>http://lin493369.github.io/2016/02/20/在WordPress中使用GithubREADME标签/</id>
    <published>2016-02-19T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://dev.iachieved.it/iachievedit/github-readme-badges-in-wordpress/" target="_blank" rel="external">http://dev.iachieved.it/iachievedit/github-readme-badges-in-wordpress/</a><br>作者=Joe<br>原文日期=2016/01/24</p>
<hr>
<p>Github 上的很多框架和包都在他们的 README 文件中使用 “badges”（标签）记录 repository 的不同属性。</p>
<ul>
<li>一个 repository 的 Travis 构建（译者注：Travis CI 是开源持续集成构建项目）是否通过</li>
<li>一个 release 版本代码的下载次数 </li>
<li>代码支持的平台（为苹果设备开发时尤其有用）</li>
</ul>
<p><img src="http://dev.iachieved.it/iachievedit/wp-content/uploads/2016/01/githubbadges.png" alt="这里写图片描述"></p>
<p>自2014年6月初次发布以来，<a href="https://en.wikipedia.org/wiki/Swift_%28programming_language%29" target="_blank" rel="external">Swift 编程语言</a>已经经历过了一系列的改变和版本。每一个发行版本都包含了破坏性的改变。从这篇文章开始，我已经开始使用标签去指明文章所兼容的 Swift 版本。</p>
<h2 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h2><p>你可以在你的 WordPress 文章中通过两种技术使用标签。严格地获取标签的最好方式是使用内联图片设计使之看起来像，好吧，就是像标签。你也可以自己创建图片或者使用类似 <a href="http://shields.io/" target="_blank" rel="external">Shields.io</a> 的服务去链接标签。不管什么方式，为了在你的页面展示标签你都应该使用<code>&lt;img/&gt;</code>。一个通过 Shields.io 链接标签的描述例子如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">img</span> src=<span class="string">"https://img.shields.io/badge/Swift-2.2-orange.svg?style=flat"</span> alt=<span class="string">"Swift 2.2"</span> /&gt;</div></pre></td></tr></table></figure>
<p>这会出现这样的标签：Swift 2.2</p>
<p>此外你还可以使用 Markdown 语法（如你在 Github 的 README.md 文件所见的那样）。为了在 WordPress 中使用 Markdown，你可以加载 <a href="https://wordpress.org/plugins/jetpack/" target="_blank" rel="external">jetpack</a> 组件，然后激活它的 Markdown 组件。通过 Markdown 的支持激活创建一篇新的文章，并且可以在文章编辑这样的类型：</p>
<p><img src="https://img.shields.io/badge/Swift-2.2-orange.svg?style=flat" alt="Swift 2.2"></p>
<p>这使用了 <a href="https://daringfireball.net/projects/markdown/syntax#img" target="_blank" rel="external">Markdown 的图片语法</a>，并且可以出现这样的标签：Swift 2.2</p>
<h2 id="Shields-io"><a href="#Shields-io" class="headerlink" title="Shields.io"></a>Shields.io</h2><p>Shields.io 的设计理念是： “标签是一个服务”。换句话说，无需担心创建你自己的标签，Shields.io 会为你创建标签。大多数的 Shields.io 标签在语义上和“一些东西”的状态捆绑在一起。例如，URL：<a href="https://img.shields.io/github/downloads/atom/atom/total.svg" target="_blank" rel="external">https://img.shields.io/github/downloads/atom/atom/total.svg</a> 提供了一个标签指明 <a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a> 程序被下载的所有次数。Shields.io 首先通过联系 Github 的接口获取到真实的下载数量，然后返回生成的图片。</p>
<p>上述 Swift 的例子使用了这个 Shields.io URL：<br><code>https://img.shields.io/badge/&lt;SUBJECT&gt;-&lt;STATUS&gt;-&lt;COLOR&gt;.svg</code>。我们通过提供如下几个选项使用他：</p>
<ul>
<li>SUBJECT 为 Swift </li>
<li>STATUS 为 2.2 </li>
<li>COLOR 为 orange</li>
</ul>
<p>当然，orange 是由于它是Swift的代表色。</p>
<h2 id="准确的评价"><a href="#准确的评价" class="headerlink" title="准确的评价"></a>准确的评价</h2><p>我非常推荐每一个Swift 博主开始使用标签 （或者一些等同的形式）去指明 Swift 语言的版本，如例子所示的那样。例如，尽管 C 风格的循环已经在 Swift 2.2 中废弃了，但是会在 3.0 中产生错误。当某个人看到你的 2.2 版本的文章，但是试图使用 3.0 的编译器运行代码，他们至少应该知道有些代码可能不兼容。</p>
]]></content>
    
    <summary type="html">
    
      Github 上的很多框架和包都在他们的 README 文件中使用 “badges”（标签）记录 repository 的不同属性。
    
    </summary>
    
      <category term="博客技巧" scheme="http://lin493369.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="博客" scheme="http://lin493369.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="WordPress" scheme="http://lin493369.github.io/tags/WordPress/"/>
    
      <category term="Github" scheme="http://lin493369.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>如何简单地模拟 NSURLSeesion 的返回数据</title>
    <link href="http://lin493369.github.io/2016/01/18/AnEasyWayToStubNSURLSession/"/>
    <id>http://lin493369.github.io/2016/01/18/AnEasyWayToStubNSURLSession/</id>
    <published>2016-01-17T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://swiftandpainless.com/an-easy-way-to-stub-nsurlsession/" target="_blank" rel="external">http://swiftandpainless.com/an-easy-way-to-stub-nsurlsession/</a><br>作者=dom<br>原文日期=2016/01/09</p>
<hr>
<p>如果你熟悉我这个博客的话，你可能知道我检查问题时，最喜欢的方法是模拟 <code>NSURLSeesion</code> 返回的数据。</p>
<p>那么我们到底要做什么呢，其实是模拟方法的回调数据。而这里的 <code>NSURLSession</code>指的是伪造 web API 的响应。这样做有一些好处，例如：</p>
<ol>
<li>我们不需要一个可用的 web API 来开发我们应用程序的网络请求。</li>
<li>能够立马响应，反馈周期更短。</li>
<li>测试程序能在没有网络连接的电脑上运行。</li>
</ol>
<p>一般来说，模拟 <code>NSURLSession</code> 的请求返回数据是通过 <code>NSURLProtocol</code> 来完成的。具体的用例请查看 <a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="external">OHHTTPStubs</a> 和 <a href="https://github.com/kylef/Mockingjay" target="_blank" rel="external">Mockingjay</a>。使用 <code>NSURLProtocol</code> 的优势在于，当你使用诸如 <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> 这样的网络请求库时，也能正常模拟数据回调。这种方式很棒，但是对我来说代码太多了。我必须去学习和理解这些代码，以在我的测试中获得预期的效果。</p>
<h2 id="一个简单的解决方案"><a href="#一个简单的解决方案" class="headerlink" title="一个简单的解决方案"></a>一个简单的解决方案</h2><p>我将使用 <code>NSURLSession</code> 来做网络请求。下面是如何伪造我的请求返回数据。</p>
<p>为了让它看起来更简单，我已经写了一个 <code>NSURLSession</code> 的替换类和一个协议。整合起来如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DHURLSession</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dataTaskWithURL</span><span class="params">(url: NSURL,</span></span></div><div class="line">    completionHandler: <span class="params">(NSData?, NSURLResponse?, NSError?)</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">NSURLSessionDataTask</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dataTaskWithRequest</span><span class="params">(request: NSURLRequest,</span></span></div><div class="line">    completionHandler: <span class="params">(NSData?, NSURLResponse?, NSError?)</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">NSURLSessionDataTask</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSURLSession</span>: <span class="title">DHURLSession</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">URLSessionMock</span> : <span class="title">DHURLSession</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> url: <span class="type">NSURL</span>?</div><div class="line">  <span class="keyword">var</span> request: <span class="type">NSURLRequest</span>?</div><div class="line">  <span class="keyword">private</span> <span class="keyword">let</span> dataTaskMock: <span class="type">URLSessionDataTaskMock</span></div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(data: <span class="type">NSData</span>?, response: <span class="type">NSURLResponse</span>?, error: <span class="type">NSError</span>?) &#123;</div><div class="line">    dataTaskMock = <span class="type">URLSessionDataTaskMock</span>()</div><div class="line">    dataTaskMock.taskResponse = (data, response, error)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dataTaskWithURL</span><span class="params">(url: NSURL,</span></span></div><div class="line">    completionHandler: <span class="params">(NSData?, NSURLResponse?, NSError?)</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">NSURLSessionDataTask</span> &#123;</div><div class="line">      <span class="keyword">self</span>.url = url</div><div class="line">      <span class="keyword">self</span>.dataTaskMock.completionHandler = completionHandler</div><div class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.dataTaskMock</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dataTaskWithRequest</span><span class="params">(request: NSURLRequest,</span></span></div><div class="line">    completionHandler: <span class="params">(NSData?, NSURLResponse?, NSError?)</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">NSURLSessionDataTask</span> &#123;</div><div class="line">      <span class="keyword">self</span>.request = request</div><div class="line">      <span class="keyword">self</span>.dataTaskMock.completionHandler = completionHandler</div><div class="line">      <span class="keyword">return</span> <span class="keyword">self</span>.dataTaskMock</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">URLSessionDataTaskMock</span> : <span class="title">NSURLSessionDataTask</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">typealias</span> <span class="type">CompletionHandler</span> = (<span class="type">NSData</span>!, <span class="type">NSURLResponse</span>!, <span class="type">NSError</span>!) -&gt; <span class="type">Void</span></div><div class="line">    <span class="keyword">var</span> completionHandler: <span class="type">CompletionHandler</span>?</div><div class="line">    <span class="keyword">var</span> taskResponse: (<span class="type">NSData</span>?, <span class="type">NSURLResponse</span>?, <span class="type">NSError</span>?)?</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">resume</span><span class="params">()</span></span> &#123;</div><div class="line">      completionHandler?(taskResponse?.<span class="number">0</span>, taskResponse?.<span class="number">1</span>, taskResponse?.<span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，用来伪造数据的完整帮助代码是 47 行。并且所有代码清晰易懂，既没有 swizzling，也没有复杂的方法。是不是很棒!</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>为了能够在测试中使用 <code>NSURLSession</code> 替换类，我们需要在代码中注入依赖。一种可能的方式是使用一个懒属性：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> session: <span class="type">DHURLSession</span> = <span class="type">NSURLSession</span>.sharedSession()</div></pre></td></tr></table></figure></p>
<p>然后一个示例测试可能会是这样的：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func testFetchingProfile_ReturnsPopulatedUser() &#123;</div><div class="line">  // Arrage</div><div class="line">  <span class="keyword">let</span> <span class="attr">responseString</span> = <span class="string">"&#123;\"</span>login\<span class="string">": \"</span>dasdom\<span class="string">", \"</span>id\<span class="string">": 1234567&#125;"</span></div><div class="line">  <span class="keyword">let</span> <span class="attr">responseData</span> = responseString.dataUsingEncoding(NSUTF8StringEncoding)!</div><div class="line">  <span class="keyword">let</span> <span class="attr">sessionMock</span> = URLSessionMock(data: responseData, response: nil, error: nil)</div><div class="line">  <span class="keyword">let</span> <span class="attr">apiClient</span> = APIClient()</div><div class="line">  apiClient.<span class="attr">session</span> = sessionMock</div><div class="line">  </div><div class="line">  // Act</div><div class="line">  apiClient.fetchProfileWithName(<span class="string">"dasdom"</span>)</div><div class="line">  </div><div class="line">  // Assert</div><div class="line">  <span class="keyword">let</span> <span class="attr">user</span> = apiClient.user</div><div class="line">  <span class="keyword">let</span> <span class="attr">expectedUser</span> = User(name: <span class="string">"dasdom"</span>, id: <span class="number">1234567</span>)</div><div class="line">  XCTAssertEqual(user, expectedUser)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我很喜欢这样的解决方案，因为我只要花几分钟时间，通过阅读五十多行代码就能理解替换类。并且没有涉及到 <code>NSURLProtocol</code> 和 <code>swizzling</code>。</p>
<p>这个 <code>NSURLSession</code> 的替换类在 <a href="https://github.com/dasdom/DHURLSessionStub" target="_blank" rel="external">github</a> 上，并且也可以通过CocoaPods 下载。</p>
<p>让我知道你的想法。</p>
]]></content>
    
    <summary type="html">
    
      如果你熟悉我这个博客的话，你可能知道我检查问题时，最喜欢的方法是模拟 `NSURLSeesion` 返回的数据。那么我们到底要做什么呢，其实是模拟方法的回调数据
    
    </summary>
    
      <category term="Test" scheme="http://lin493369.github.io/categories/Test/"/>
    
    
      <category term="test" scheme="http://lin493369.github.io/tags/test/"/>
    
      <category term="效率" scheme="http://lin493369.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="NSURLSeesion" scheme="http://lin493369.github.io/tags/NSURLSeesion/"/>
    
  </entry>
  
  <entry>
    <title>Swift：带有私有设置方法的公有属性</title>
    <link href="http://lin493369.github.io/2016/01/08/Swift-PublicPropertiesWithPrivateSetters/"/>
    <id>http://lin493369.github.io/2016/01/08/Swift-PublicPropertiesWithPrivateSetters/</id>
    <published>2016-01-07T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://www.thomashanning.com/public-properties-with-private-setters/" target="_blank" rel="external">http://www.thomashanning.com/public-properties-with-private-setters/</a><br>作者=Thomas<br>原文日期=2015/12/24</p>
<hr>
<p>Swift可以很方便地创建带有私有设置方法的公有属性。这可以让你的代码更加安全和简洁。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装从根本上意味着类的信息和状态应该对外部类隐藏，只有类自身可以操作。因此，所有的 bug 和 逻辑错误更加不可能发生了。</p>
<p>通常你会使用 setter 以及 getter 来达到封装的目的。然而，有时候你可能不想对外提供类中的设置方法。对于这样的情况，你可以使用带有私有设置方法的属性。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们想要创建一个代表圆的类，那么圆的半径应该是可以改变的。而且，该圆的面积和直径应该可以从圆的实例中获取，而这两个属性不允许被外部类更改。出于性能考虑，面积和直径只能计算一次。</p>
<p>所以这个圆类应该是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            calculateFigures()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.radius = radius</div><div class="line">        calculateFigures()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</div><div class="line">        area = <span class="type">M_PI</span> * radius * radius</div><div class="line">        diameter = <span class="number">2</span> * <span class="type">M_PI</span> * radius</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getArea</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">return</span> area</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getDiameter</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">return</span> diameter</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在所有的需求都满足啦。然而，Swift 提供了一种更好的方式，可以使得这段代码更加简洁：</p>
<h2 id="带有私有设置方法的属性"><a href="#带有私有设置方法的属性" class="headerlink" title="带有私有设置方法的属性"></a>带有私有设置方法的属性</h2><p>通过在属性前面使用 <code>private(set)</code> ，属性就被设置为默认访问等级的 getter 方法，但是 setter 方法是私有的。所以我们可以去掉两个 getter 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            calculateFigures()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.radius = radius</div><div class="line">        calculateFigures()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</div><div class="line">        area = <span class="type">M_PI</span> * radius * radius</div><div class="line">        diameter = <span class="number">2</span> * <span class="type">M_PI</span> * radius</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然也可以为属性设置公有的 getter 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            calculateFigures()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.radius = radius</div><div class="line">        calculateFigures()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</div><div class="line">        area = <span class="type">M_PI</span> * radius * radius</div><div class="line">        diameter = <span class="number">2</span> * <span class="type">M_PI</span> * radius</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在这个例子中，属性只是 <code>Double</code> 值。然而，如果是一个对象，可以通过使用对象的方法来操作！使用私有设置方法只允许设置一个全新的对象，在使用过程中应铭记这一点。</p>
]]></content>
    
    <summary type="html">
    
      Swift可以很方便地创建带有私有设置方法的公有属性。这可以让你的代码更加安全和简洁。
    
    </summary>
    
      <category term="Swift 入门" scheme="http://lin493369.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Swift" scheme="http://lin493369.github.io/tags/Swift/"/>
    
      <category term="封装" scheme="http://lin493369.github.io/tags/%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS 启动时优化</title>
    <link href="http://lin493369.github.io/2016/01/05/iOS%E5%90%AF%E5%8A%A8%E6%97%B6%E4%BC%98%E5%8C%96(1)/"/>
    <id>http://lin493369.github.io/2016/01/05/iOS启动时优化(1)/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>译者：本文虽是针对 Facebook 应用的启动时优化，文中所说的大部分优化策略对于小型应用来说意义可能并不是很大，但是重要的是，我们应学习Facebook 工程师通过一系列系统的考量寻求优化解决方案的方式。首先通过建立优化的度量指标，明确优化方向，分解优化目标，分步达到优化目的，最后统一测试优化效果。相较于杂乱无章，碰运气式的优化经验，这种清晰有条理的解决方式，着实令人敬佩。</p>
<hr>
<p>提高 Facebook 应用的性能已经成为 Facebook 持续关注的领域。因为我们相信一个高性能的应用能够传递一种吸引人且令人愉悦的体验。每个 Facebook 应用的用户都必须做的一件事是启动应用（我们特指这个动作为 ”应用启动“）。因此，这是一个很好的优化目标。</p>
<h2 id="稳定的度量"><a href="#稳定的度量" class="headerlink" title="稳定的度量"></a>稳定的度量</h2><p>实现最好的性能度量标准和相应的目标，鼓舞我们专注于提升应用的品质，并且我们相信这将会产生很大的影响。度量必须易懂、经得起推敲，并且需要精确地捕捉到将要被优化的体验。对基于性能的度量，我们已经发现在使用应用过程中，最好是使用那些被捕捉到感知的交互。理想情况下，这些度量应该和一个通过基础设施的单一执行通道有一对一的联系。对于应用程序的启动，确定用于衡量的关键位置是一个挑战。这需要采取几次迭代去简化我们的测量和移除边界问题。</p>
<p>应用启动是一个特别不固定的概念，因为现在存在很多种应用启动的方式。应用可以在后台或者前台启动，甚至可以在后台启动，但是在完成初始化之前转换为前台。你可以通过点击一条通知或者通过一个 URL 打开应用。Facebook 应用甚至可以通过其他应用来打开，因为他们需要通过 Facebook 来实现第三方登录。在现实场景中，主要的交互还是最直接的方式：你点击桌面的应用图标，然后跳转启动。因而，我们选择这个作为应用启动的入口。</p>
<p>当启动入口明确之后，我们必须去计算出何时应用启动是完成的。同样地，我们观察用户的使用模式，发现用户喜欢打开应用（首先跳转到新闻摘要），然后等待摘要的加载。我们断定“摘要完成加载”是应用启动一个很好的终点。我们采取了一些微调使得这个终点契合用户的使用情况。我们可以通过重复地观察应用的启动，围绕度量标准来提高应用的性能。</p>
<p>一旦确定了我们认为有代表性的启动入口和终点，我们把启动问题分解成两种类型：</p>
<ol>
<li>冷启动。指的是当应用还没准备好运行时，我们必须加载和构建整个应用。这包括设置屏幕底部的分栏菜单，确保用户是否被合适地登录，以及处理其他更多的事情。“引导”程序是在<code>applicationDidFinishLaunching:withOptions:</code>方法中开始的。</li>
<li>热启动。指的是应用已经运行但是在后台被挂起（比如用户点击了 home 健），我们只需要知道在何时应用进入后台。在这种情况下，我们的应用通过 <code>applicationWillEnterForeground:</code> 接收到前台的事件，紧接着应用恢复。</li>
</ol>
<p>我们决定主要优化冷启动，主要有两个原因。首先，冷启动其实是包括热启动的（冷启动初始化应用并获得摘要；热启动只获得摘要），所以有更多的地方需要优化和微调。第二，冷启动需要做额外的初始化工作，所以相较而言更慢，导致需要更长的启动等待时间。</p>
<h2 id="优化冷启动体验"><a href="#优化冷启动体验" class="headerlink" title="优化冷启动体验"></a>优化冷启动体验</h2><p>我们把冷启动问题分解成三个阶段，进而我们可以有针对性地解决。每个阶段都有一些列变数和挑战。</p>
<ol>
<li>请求时间：从应用启动到摘要请求离开设备（译者：应该是向服务器发送URL请求算结束时间）的时间。</li>
<li>网络时间：从摘要请求离开设备到服务器响应返回的时间。</li>
<li>响应处理时间：从响应返回到新数据展示在屏幕的时间。</li>
</ol>
<p>我们直观上认为冷启动性能主要被网络请求和响应处理影响了。这个结论是由于我们假定我们在客户端花的时间比较少，并且我们设法让请求的获取更加快速。然而，当我们用 instrument 去检测时，我们发现数据非常出人意料。它展现出了完全不同的结果，我们发现摘要请求花了大部分时间。另外，响应的处理时间也非常短。因此，我们重新把优化的焦点放在初始化阶段。</p>
<h2 id="摘要请求发送的初始化"><a href="#摘要请求发送的初始化" class="headerlink" title="摘要请求发送的初始化"></a>摘要请求发送的初始化</h2><p>所以为什么这个阶段花费了那么多时间呢？很多 iOS 应用并没有这样一个问题——他们在那个阶段并没有很多工作需要做，除了初始化视图控制器和发送网络请求。然而，对于 Facebook 来说，大部分时间被用来开始的时候去设置不同功能块。下面是我们应用中的主要功能块的流程概览。<br><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-xfp1/t39.2365-6/12057214_1016971454990542_827610883_n.png" alt="这里写图片描述"></p>
<p>这看起来好像是很复杂的应用启动设置。但需要重视的是，这些功能块对于 Facebook 应用来说是非常重要的提升，可以提高应用体验，并且使得工程师能够在不同的应用规模下更快地开发。</p>
<p>正如我们所关注的这个流程，我们通过优化独立的部分获得了一些主要的成果。然而，由于未来支持新特性的初始化以及额外提供支持的基础设施，这些成果会慢慢地抵消掉。这使得我们重新考虑如何去解决问题。但我们重新开始，我们认为这个阶段的目标是简单地发送摘要的网络请求。但是为什么摘要请求发出去得这么慢？这是由于很多依赖被添加到摘要的初始化中了。然而，他们并不都是必要的 — 对于摘要请求来说，最少的需要一个有效的验证 token 以及摘要光标（新闻摘要的位置）。因此，我们减少了摘要请求的依赖，让它逐渐地更加接近应用的启动。这允许应用的剩余部分在摘要响应的同时进行初始化。由于这些重构，我们获得了显著的收益。</p>
<h2 id="网络和服务器时间"><a href="#网络和服务器时间" class="headerlink" title="网络和服务器时间"></a>网络和服务器时间</h2><p>根据我们在第一阶段的经验，我们继续把这个阶段分解成更小的部分。网络请求/响应看起来像这样：<br><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-xtp1/t39.2365-6/12056998_991399770918380_262846919_n.png" alt="这里写图片描述"></p>
<p>我们注意到，一旦请求正在排队，发送请求出去之后就有一个时间间隔。这很好解释 — 在冷启动中，网络连接并不是一个开放的、安全的 TCP 连接。一个连接的建立需要三次握手，平均为几百毫秒。当摘要请求第一次发送时，无法避免要花掉这些时间。长远来看，这可以通过缓存 SSL 证书来解决。但是再次强调，我们退回来的目的并不是为了发送 TCP 请求，而是为了从服务器通过任何可能的方式获得请求信息。</p>
<p>我们提出了一个创造性的解决方案 — UDP 启动。本质上，我们在通过 TCP 发送摘要请求时，先发送一个编码过的包含摘要请求的 UDP 包到服务器。这样做的目的是唤醒服务器更早地去获取和缓存数据。当真正的摘要请求通过 TCP 到达时，服务器只需见到地从缓存内容中构造出响应，并发回客户端。这个技术使得我们可以减少几百毫秒的耗时。</p>
<p>当我们持续深入研究服务器端时，我们开始尝试使用 层-取（story-fetching）策略。过去我们已经做了一批摘要请求的 3+7 层。原因很简单：下载次数和被下载的层成正比。因此，把请求分割成两块，允许开始的三层先进来，其余的七个随后进来。通过提升我们的基础设施，我们已经能够升级为 1+1+X 策略，这已经接近于流了。这样就减少了服务器必须处理第一层的时间，并且能够减少下载的时间，使得可以在最快的时间内与用户交互。通过这样的努力，这样我们又减少了几百毫秒的耗时。</p>
<h2 id="摘要响应处理"><a href="#摘要响应处理" class="headerlink" title="摘要响应处理"></a>摘要响应处理</h2><p>正如在前面提到的那样，我们以为在启动时会在这里花费大量的时间。但是这个想法被证明是错误的。更加使人好奇的是，我们注意到时间并没有花在处理和加工层上面。时间被花在运行应用服务和竞争资源上面。我们注意到这是我们优化网络和服务器时间的副作用，因为摘要请求返回得太早了。尽管大多数的服务是不重要的。因此，我们开发出一个简单的机制去序列化这些工作直到应用完成启动，并且使用先进先出的方式去执行。这样可以用更少的连接去处理所有层，大大地减少了获得响应和展示在屏幕之间的时间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很难理解我们在过去几个月走了多远。总之，在一对一的比较中，我们发现我们成功地优化了一秒多的耗时。</p>
<p>优化这个特殊的交互是一个长期的过程，需要建立一个稳定的度量，这个度量必须是易懂的、符合真实世界性能特征，此外要不断地重新思考问题，以提出创新的解决方案。我们希望这可以帮助使用 Facebook 的人有更好的、令人愉悦的用户体验。</p>
<p>你也可以看看 <a href="https://youtu.be/ifozUqqC0TY?t=11m5s" target="_blank" rel="external">Greg Moeck在 2015 年的演讲</a> 。</p>
]]></content>
    
    <summary type="html">
    
      Facebook 工程师通过一系列系统的考量寻求优化解决方案的方式。首先通过建立优化的度量指标，明确优化方向，分解优化目标，分步达到优化目的，最后统一测试优化效果。
    
    </summary>
    
      <category term="性能优化" scheme="http://lin493369.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Facebook" scheme="http://lin493369.github.io/tags/Facebook/"/>
    
      <category term="优化" scheme="http://lin493369.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="启动时" scheme="http://lin493369.github.io/tags/%E5%90%AF%E5%8A%A8%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>关于 Swift 演变的趣味探讨</title>
    <link href="http://lin493369.github.io/2015/12/27/interesting-discussions-on-swift-evolution/"/>
    <id>http://lin493369.github.io/2015/12/27/interesting-discussions-on-swift-evolution/</id>
    <published>2015-12-26T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/" target="_blank" rel="external">http://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/</a><br>作者=Erica Sadun<br>原文日期=2015/12/15</p>
<hr>
<p>记得我曾分享过一些想法和建议，比如：</p>
<h3 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a>newtype</h3><p>一个是建议 Swift 推出一个 <code>newtype</code> 的关键词，它可以添加完全不同于原生的可扩展的派生类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newtype <span class="type">Currency</span> = <span class="type">NSDecimal</span></div></pre></td></tr></table></figure>
<p>这创建了一个拥有所有 <code>NSDecimal</code> 所有行为的 <code>Currency</code> 类型。然而，你不能让一个 <code>NSDecimal</code> 类型的元素和一个 <code>Currency</code> 类型的元素相加，因为 Swift 中有类型检测。此外，你也可以扩展 <code>Currency</code> 类型。这样看起来就更加有针对性，因为不需要子类化或者添加新的存储属性。</p>
<a id="more"></a>
<p><code>newtype</code> 的另一个特性是能够创建柯里化类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newtype <span class="type">Counter</span>&lt;<span class="type">A</span>&gt; = <span class="type">Dictionary</span>&lt;<span class="type">A</span>, <span class="type">Int</span>&gt;</div></pre></td></tr></table></figure>
<p>类型是部分确定的，具体行为可以在扩展中实现，从而能包含键（key）类型不相同但值类型都是 Int 的字典。</p>
<p>期待看到你们的评论。</p>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p>另外一个提议是将 <code>self</code> 作为强制前缀，取代上下文语境推断。Greg Parker 在回复中写道：</p>
<blockquote>
<p>在 Objective-C 中 <code>self.property</code> 这种写法很不优雅。</p>
<p>第一种方法是只使用 <code>property</code>。但是同名变量（ivar）会产生歧义，Swift 没有这样的问题。</p>
<p>第二种方法是用 <code>property</code> 访问属性，用 <code>self-&gt;ivar</code> 去访问同名变量。这是不可行的，因为会和现有的大量代码冲突。Swift 也没有这样的问题。</p>
</blockquote>
<h3 id="前置条件与断言（Precondition-vs-Assert）"><a href="#前置条件与断言（Precondition-vs-Assert）" class="headerlink" title="前置条件与断言（Precondition vs Assert）"></a>前置条件与断言（Precondition vs Assert）</h3><p>Dave Abrahams 提出了一个有关重命名断言和前置条件的建议，我立刻将其中的一些深刻见解记在笔记本上：</p>
<blockquote>
<p>从语言设计层面来说，这两个函数扮演不同的角色：<br>– assert：检查内部的错误代码。<br>– precondition：检查客户端给你的参数是否有效。</p>
<p>两者的区别很大，第二个要求有公共文档，第一个不需要。</p>
<p>例如：在 Swift 的标准库中，我们保证永远不会出现内存错误，除非你调用 (Obj)C 代码或者使用一个明确地标着「unsafe」的结构。我们需要去检验客户端参数，为了避免给了非法的参数引起内存泄露，我们要在参数中文档化这些需求作为前置条件，并且使用（等价的）precondition() 去检验它。我们还有一系列的内部合理检查，用以确定我们代码假定的正确性，而类型系统还不能保证这个代码的假定。由于这些原因，我们使用（等价的）assert()，因为我们不想降低<em>你的</em>代码性能（使用合理的检查）。</p>
<p>下面是几个具体的例子：</p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 一个集合，其中的元素类型为 Element</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Repeat</span>&lt;<span class="title">Element</span>&gt; : <span class="title">CollectionType</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">/// 获取 `position` 位置的元素</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - 要求: `position` 是 `self` 中的有效位置并且 `position != endIndex`.</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</div><div class="line">    _precondition(position &gt;= <span class="number">0</span> &amp;&amp; position &lt; <span class="built_in">count</span>, <span class="string">"Index out of range"</span>)</div><div class="line">    <span class="keyword">return</span> repeatedValue</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">UTF8View</span> </span>&#123;</div><div class="line">  ...</div><div class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">_encodeSomeContiguousUTF16AsUTF8</span><span class="params">(i: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">UTF8Chunk</span>) &#123;</div><div class="line">    _sanityCheck(elementWidth == <span class="number">2</span>)</div><div class="line">    _sanityCheck(!_baseAddress._isNull)</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> storage = <span class="type">UnsafeBufferPointer</span>(start: startUTF16, <span class="built_in">count</span>: <span class="keyword">self</span>.<span class="built_in">count</span>)</div><div class="line">    <span class="keyword">return</span> _transcodeSomeUTF16AsUTF8(storage, i)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在第一个例子中，我们有一个判断客户的 collection 没有越界的前置条件。在这个例子中，我们其实可以不做检查，因为越界也不会导致内存错误（因为返回的都是同一个 repeatedValue），但是我们还是加上了这个检查，这样我们的用户可以快速发现他们的 bug 。</p>
<p>第二个例子中是一个私有函数，它只能在我们保证 elementWidth == 2 和 _baseAddress 不为 null 的条件下调用（_sanityCheck 在 stdlib 下等价于 assert）。因为这是私有函数，使用者就是我们自己，所以看起来这个检查可以省略。但是有时候会出意外，比如后续的开发者可能会错误地使用它，因此我们需要添加检查。因为我们在 debug 和 release 的环境下运行我们的测试，并且有较高的测试覆盖率，因此（如果错误使用函数）断言很可能在某处被触发。</p>
<p>读完上面的内容，你可能认为 assert() 只能在私有方法中使用，而 precondition() 只能在公共方法中使用。事实并非如此；你可以内联任何私有方法到继承的公有方法的方法体内，因此合理的检查依然有意义。前置条件检查也会偶尔在私有方法中使用，最简单的例子就是公有方法转私有方法，复制代码的时候可以把原来的前置条件检查提取成一个私有的辅助方法（Helper）。</p>
<p><sup>*</sup>注意，有些前置条件实际上不会被执行，所以你不能指望所有的前置条件都被执行。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      记得我曾分享过一些想法和建议，比如：newtype 。一个是建议 Swift 推出一个 newtype 的关键词，它可以添加完全不同于原生的可扩展的派生类型。
    
    </summary>
    
      <category term="Swift 入门" scheme="http://lin493369.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Swift" scheme="http://lin493369.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>如何简单地为测试切换 App Delegate</title>
    <link href="http://lin493369.github.io/2015/12/19/HowtoEasilySwitchYourAppDelegateforTesting/"/>
    <id>http://lin493369.github.io/2015/12/19/HowtoEasilySwitchYourAppDelegateforTesting/</id>
    <published>2015-12-18T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://qualitycoding.org/app-delegate-for-tests/" target="_blank" rel="external">http://qualitycoding.org/app-delegate-for-tests/</a><br>作者=Jon Reid<br>原文日期=2015/03/17</p>
<hr>
<p><a href="http://qualitycoding.org/benefit-of-tdd/" target="_blank" rel="external">测试驱动的开发最大好处是能够有快速反馈</a>（译者：这是作者的另一篇文章，讲述了测试驱动的好处，有兴趣的可以看看）。所以，为了确保你的 TDD 效率，最好的方式就是尽可能快地获得反馈。</p>
<p>但是很多 iOS 开发者会在测试的时候使用生产环境（译者：应用开发中的不同阶段，一般分为开发环境 development，处于产品开发阶段；生产环境 production，即正式上线的环境，更详细的请参照 <a href="https://en.wikipedia.org/wiki/Development,_testing,_acceptance_and_production" target="_blank" rel="external">Development, testing, acceptance and production</a>）的 app delegate。这是一个影响效率的问题。</p>
<p>你的常规 app delegate 在用于测试时是否跟龟速一样？</p>
<p><img src="http://qualitycoding.org/jrwp/wp-content/uploads/2015/03/turtle.jpg" alt="这里写图片描述"></p>
<p>这是因为当你测试运行时，首先要启动你的应用——而这个过程可能做了很多事情，大量耗时的操作。而这些耗时的操作在测试的时候并不是我们所需要的。</p>
<p>我们应该如何避免这个问题？</p>
<h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><p>Apple 习惯将单元测试归为两类：应用测试和逻辑测试。这个区别是非常重要的，因为在以前，应用测试只能在设备上运行，除非你使用完全不同的第三方测试框架。</p>
<p>但是这个差异现在消失了，因为 Apple 允许我们在模拟器上运行应用测试。Apple 花了很多时间来更新文档，直到在他们最新的<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/Introduction/Introduction.html" target="_blank" rel="external">Xcode测试</a>才更新了这部分说明，Apple 现在称之为 “app tests” 和 “library tests”。这就使事情简化为你是开发一个应用还是一个库。并且 Xcode 为你设置了一个测试用的 target ，这正是你所需要的。</p>
<p>如果我现在开发一个应用（或者一个需要运行应用的库），我总是会运行应用测试，所以我<a href="http://qualitycoding.org/xcode-unit-testing/" target="_blank" rel="external">停止去试图区分这两种类型的测试</a>。但是由于 Xcode 是在一个运行的应用的上下文环境下执行应用测试，测试流程就变成这样：</p>
<ol>
<li>启动模拟器 </li>
<li>在模拟器中，启动应用 </li>
<li>将测试 bundle 注入运行的应用 </li>
<li>运行测试</li>
</ol>
<p>那么我们怎么才能加快这个流程呢？我们可以在第二步中做文章，让应用尽可能快地启动。</p>
<h2 id="普通的-app-delegate"><a href="#普通的-app-delegate" class="headerlink" title="普通的 app delegate"></a>普通的 app delegate</h2><p>在开发环境下，启动应用可能会关闭很多任务。Ole Begemann 在 <a href="http://oleb.net/blog/2012/02/app-launch-sequence-ios-revisited/" target="_blank" rel="external">Revisiting the App Launch Sequence on iOS</a>中进行了详细的解释，但是根本上， <code>UIApplicationMain()</code> 最终会调用 app delegate去执行 <code>application:didFinishLaunchingWithOptions:</code> 。具体的流程一般取决于你的应用，但是很少会像下面这么做：</p>
<ol>
<li>创建 Core Data。</li>
<li>配置根视图控制器</li>
<li>检测网络连通性</li>
<li>向服务器发送一个网络请求去取回最近的配置，例如应该在根视图中展示的东西。</li>
</ol>
<p>因此在开始测试之前要做很多事情。难道不能使我们的测试不受干扰，如果我们想要的只是运行我们的测试程序？</p>
<p>让我们来解决这个问题，下面是具体方案。</p>
<h2 id="改变-main-函数"><a href="#改变-main-函数" class="headerlink" title="改变 main 函数"></a>改变 main 函数</h2><p>让我们改变我们的 main 函数，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在想要去检查是否我们在运行测试代码。如果想要这么做的话，我们想要去使用一个不同的 app delegate。我们可以这么做：</p>
<p>最早的版本<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TestingAppDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="built_in">BOOL</span> isTesting = <span class="built_in">NSClassFromString</span>(<span class="string">@"XCTestCase"</span>) != Nil;</div><div class="line">        Class appDelegateClass = isTesting ? [TestingAppDelegate <span class="keyword">class</span>] : [AppDelegate <span class="keyword">class</span>];</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>(appDelegateClass));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从根本上来说，如果 XCTestCase 链接好了，我们就会使用 <code>TestingAppDelegate</code>。否则，我们退而使用生产环境的 app delegate。然后我们启动应用时可以选择我们想要的 app delegate。（注意：TestingAppDelegate 必须在生产环境的 target 中）</p>
<p>现在这些代码已经实现了来回切换。上述部分的实现从根本上和我原先的文章一致。因为有一段时间，根据评论中的建议，我将代码改为：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">Class appDelegateClass = <span class="built_in">NSClassFromString</span>(@”XYZTestingAppDelegate”);</div><div class="line"><span class="keyword">if</span>( appDelegateClass == <span class="literal">nil</span> ) &#123;</div><div class="line">appDelegateClass = [DOAAppDelegate <span class="keyword">class</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>(appDelegateClass));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是在Xcode7上不能正常运行，所以我又改回原始版本。</p>
<p>如果你想在单元测试外部使用 XCTest 该怎么办，例如 UI 测试？为了取代为 XCTestCase 做的测试，你可以设置一个环境变量，通过 getenv 来测试。</p>
<h2 id="提供-TestingAppDelegate"><a href="#提供-TestingAppDelegate" class="headerlink" title="提供 TestingAppDelegate"></a>提供 TestingAppDelegate</h2><p>这里需要创建一个 TestingAppDelegate 类。正如下面代码所示：</p>
<p>TestingAppDelegate.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestingAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWindow</span> *window;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>TestingAppDelegate.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"TestingAppDelegate.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestingAppDelegate</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>正如你所看到的那样，不要做任何事。</p>
<p>（在早先的 iOS 版本中，我必须添加更多的代码，导致 TestingAppDelegate  会创建一个 window，给这个 window 设置一个不做任何事情的根视图，然后让其可见。现在看来没必要了。）</p>
<h2 id="快速反馈的本质"><a href="#快速反馈的本质" class="headerlink" title="快速反馈的本质"></a>快速反馈的本质</h2><p>最重要的事情是我们已经从本质上减少了测试过程中启动应用的步骤。尽管还有一些不必要的开销，但是并不多。这是实现快速反馈过程中重要的一步，这样我们就可以从 TDD 中获得更多。</p>
<p>甚至当你开始一个新的项目，我推荐尽早使用这样的方法，因为你真正的app delegate最终会变得日益庞大。让我们在襁褓中阻止这种问题，然后保持快速的反馈。</p>
<p>另外一个好处是，通过完全控制哪部分该测试，什么时候测试，我们现在可以编写跟生产环境的app delegate完全不同的单元测试。这显然是双赢的。</p>
]]></content>
    
    <summary type="html">
    
      这是因为当你测试运行时，首先要启动你的应用——而这个过程可能做了很多事情，大量耗时的操作。而这些耗时的操作在测试的时候并不是我们所需要的。我们应该如何避免这个问题？
    
    </summary>
    
      <category term="Test" scheme="http://lin493369.github.io/categories/Test/"/>
    
    
      <category term="test" scheme="http://lin493369.github.io/tags/test/"/>
    
      <category term="效率" scheme="http://lin493369.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="AppDelegate" scheme="http://lin493369.github.io/tags/AppDelegate/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation &amp; Facebook&#39;s POP</title>
    <link href="http://lin493369.github.io/2015/12/17/CoreAnimation&amp;Facebook&#39;sPOP/"/>
    <id>http://lin493369.github.io/2015/12/17/CoreAnimation&amp;Facebook&#39;sPOP/</id>
    <published>2015-12-16T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信很多人对实现 iOS 中的动画效果都特别头疼，往往懒得动手，功能实现不就得了，何必要那么花哨、装13的东西。但是看到别人的炫酷动效，心中又瘙痒不已，便下定决心学习，于是开始翻看 Core Animation、UIView动画（其实是<a href="http://www.jianshu.com/p/72f4cca98b0e" target="_blank" rel="external">对Core Animation的一种封装</a>）相关资料。不小心看到一群大神正在热烈讨论，钻一进去一看，原来是 <a href="https://github.com/facebook/pop" target="_blank" rel="external">POP</a> （潜意识：Facebook出品必属精品），这还学什么Core Animation，果断pod一个来玩玩，于是你就左手CA，右手 POP 开森地把玩起来了。</p>
<p>此时，你可能已经学会了CA的基本使用方法，也对UIView动画的便捷感到惊喜，但是不满足的你，显然有更高的追求，POP 以其灵活的用法，丰富的动效，完整的API文档，深得很多程序员的喜爱。作为一个有逼格的程序员，这么流行的框架，必然是值得深入学习的，但是你是否考虑过这样的第三方动画框架是否存在什么不足。因此，作为一个有追求的程序员，有必要来稍微深入地探讨一下 Core Animation 和 POP 不同点。</p>
<h2 id="Core-Animation-工作机制"><a href="#Core-Animation-工作机制" class="headerlink" title="Core Animation 工作机制"></a>Core Animation 工作机制</h2><p>首先我们需要了解CA是如何工作的。每当我们创建并添加动画到 layer 时，<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/QuartzCoreRefCollection/index.html" target="_blank" rel="external">QuartzCore</a> 框架就会把动画的参数打包好，然后通过 IPC （处理器）发送给名为 <a href="https://theiphonewiki.com/wiki/Backboardd" target="_blank" rel="external">backboardd</a> 的后台处理程序。你的应用也会发送当前展示在屏幕上的每一个 layer 的信息。</p>
<p>backboardd 会处理 layer 的结构体系然后通过 OpenGL 绘制出来。它还会处理你已经添加过的动画（也可以是视图，因为视图本质是包裹着 layer的）。你一定要理解的是，backboardd 使得动画的每一帧都可以在你的应用中完全独立。这里唯一的回调是动画的开始和结束（详见<code>CAAnimationDelegate</code> 协议）。你的应用完全不会参与动画的绘制，这些绘制完全独立于你的应用进程（除非你明确地在你的应用中通过<a href="http://www.objc.io/issue-12/animating-custom-layer-properties.html" target="_blank" rel="external">动画通用属性</a>要求绘制动画帧）。这意味着你可以继续在主线程做其他事情，并且不会影响到 <a href="https://developer.apple.com/Library/mac/documentation/GraphicsImaging/Reference/CAAnimation_class/index.html" target="_blank" rel="external">CAAnimation</a> 的性能。如果你阻塞了你的主线程，或者你在调试器中暂停了你的程序，你的动画还是会继续执行。</p>
<p>但是你可能会有这样的疑问：每个 <a href="https://developer.apple.com/library/mac/Documentation/GraphicsImaging/Reference/CALayer_class/index.html" target="_blank" rel="external">CALayer</a> 不是还有一个 presentationLayer 属性吗？</p>
<blockquote>
<p>presentationLayer的官方解释： </p>
<p>“While an animation is in progress, you can retrieve this object and use it to get the current values for those animations.”</p>
</blockquote>
<p>当CAAnimation发生时，你在屏幕上看到的实际上是 presentation layer 的改变。如果你访问 presentation layer，QuartzCore 将会计算现有的帧状态，并且使用这个帧状态去构建 presentation layer 对象。因为动画状态在动画执行期间一直处于改变，因此你将会获得近似值。</p>
<h2 id="POP-工作机制"><a href="#POP-工作机制" class="headerlink" title="POP 工作机制"></a>POP 工作机制</h2><p>现在有很多优秀的第三方动画库，POP 因为其使用灵活、功能强大、文档齐全，所以备受好评，先看一下官方介绍：</p>
<blockquote>
<p>POP是一个在iOS与OS X上通用的极具扩展性的动画引擎 它在基本的静态动画的基础上增加的弹簧动画与衰减动画<br>使之能创造出更真实更具物理性的交互动画 POP的API可以快速的与现有的ObjC代码集成并可以作用于任意对象的任意属性<br>POP是个相当成熟且久经考验的框架 Facebook出品的令人惊叹的Paper应用中的所有动画和效果即出自POP</p>
</blockquote>
<p>更为详细的介绍和使用请查看<a href="https://github.com/facebook/pop" target="_blank" rel="external">官方文档</a>以及里脊串的 <a href="http://adad184.com/2015/03/11/intro-to-pop/" target="_blank" rel="external">POP介绍与使用实践(快速上手动画)</a>。</p>
<p>POP 本质上是基于定时器的动画库，使用每秒 60 频率的定时器，即时钟频率为 1/60 秒（为了匹配 iOS 显示屏帧率），使得动画刷新绘制频率与屏幕刷新频率一致。很多这类动画库都使用 CADisplayLink 做为一个回调源。</p>
<p>一旦定时器刷新，动画库计算动画的进程，这意味着动画库会计算那些活动的东西的状态（通常是layer 属性，如 bound，opactiy，transform 等）。然后动画库提供最新计算的值给有动画的 layer （或者其他对象）。最主要的区别是，layer 的状态将会在这种情况下改变。</p>
<p>由于 layer 的一些参数已经被改变，你的应用必须通过 IPC 通知 backboardd 处理这些变化。当 backboardd 接收到变化通知（同时接收到的还有应用中的 layer 树），它将在屏幕上重绘一切东西。这意味着，你应用中做的每一个动画帧都会传送数据到 backboardd （即通知 backboardd ），因为 backboardd 完全不知道 layer 发生了什么事情。综上，你的应用就是在这种情况下运行动画的。</p>
<h2 id="Core-Animation-和-POP-运行动画对比"><a href="#Core-Animation-和-POP-运行动画对比" class="headerlink" title="Core Animation 和 POP 运行动画对比"></a>Core Animation 和 POP 运行动画对比</h2><p>由于 POP 是基于定时器定时刷新添加动画的原理，那么如果将动画库运行在主线程上，会由于线程阻塞的问题导致动画效果出现卡顿、不流畅的情况。更为关键的是，你不能将动画效果放在子线程，因为你不能将对 view 和 layer 的操作放到主线程之外。</p>
<p>为了验证上述的观点，我做了一个实验，首先用CA动画制作一个可以旋转的 view：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UIView *viewCA = [[UIView alloc]initWithFrame:CGRectMake(<span class="number">50</span>,<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)]<span class="comment">;</span></div><div class="line">   viewCA.<span class="keyword">backgroundColor </span>= [UIColor <span class="keyword">blueColor];</span></div><div class="line">   [self.view <span class="keyword">addSubview:viewCA];</span></div><div class="line">   CABasicAnimation *caAnimation = [CABasicAnimation animationWithKeyPath:@<span class="string">"transform.rotation.z"</span>]<span class="comment">;</span></div><div class="line">   caAnimation.toValue = @(M_PI)<span class="comment">;</span></div><div class="line">   caAnimation.duration = <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span></div><div class="line">   caAnimation.repeatCount = <span class="number">500</span><span class="comment">;</span></div><div class="line">   [viewCA.layer <span class="keyword">addAnimation:caAnimation </span>forKey:@<span class="string">"anim"</span>]<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>再创建一个利用 POP 动画库制作的可旋转 view：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">UIView</span> *viewPOP = [[UIView alloc]initWithFrame:</div><div class="line"><span class="symbol">CGRectMake</span>(CGRectGetWidth(<span class="keyword">self.view.bounds) </span>- <span class="number">100</span> - <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>)]<span class="comment">;</span></div><div class="line">   viewPOP.<span class="keyword">backgroundColor </span>= [UIColor yellowColor]<span class="comment">;</span></div><div class="line">   [<span class="keyword">self.view </span><span class="keyword">addSubview:viewPOP];</span></div><div class="line">   <span class="keyword">POPBasicAnimation </span>*<span class="keyword">popAnimation </span>= [<span class="keyword">POPBasicAnimation </span>animationWithPropertyNamed:kPOPLayerRotation]<span class="comment">;</span></div><div class="line">   <span class="keyword">popAnimation.toValue </span>= <span class="comment">@(M_PI);</span></div><div class="line">   <span class="keyword">popAnimation.duration </span>= <span class="number">2</span>.<span class="number">0</span><span class="comment">;</span></div><div class="line">   <span class="keyword">popAnimation.repeatCount </span>= <span class="number">500</span><span class="comment">;</span></div><div class="line">   [viewPOP.layer <span class="keyword">pop_addAnimation:popAnimation </span>forKey:<span class="comment">@"rotation"];</span></div></pre></td></tr></table></figure></p>
<p>在没有线程阻塞的情况下，对比两个动画库的运行效果如下：</p>
<p><img src="http://img.blog.csdn.net/20151217112919922" alt="这里写图片描述"></p>
<p>可以看出来虽然在没有线程阻塞，但是 POP 的动画在结束时有一个明显的停止动作，是因为 POP 的动画效果不好吗？</p>
<p>答案是 <code>timingFunction</code>。</p>
<p>CoreAnimation 和 POPBasicAnimation提供同样的四种 <code>timingFunction</code>：</p>
<blockquote>
<p>kCAMediaTimingFunctionLinear<br>kCAMediaTimingFunctionEaseIn<br>kCAMediaTimingFunctionEaseOut<br>kCAMediaTimingFunctionEaseInEaseOut<br>kCAMediaTimingFunctionDefault</p>
</blockquote>
<p>重点说一下：kCAMediaTimingFunctionDefault（引自：<a href="http://www.cocoachina.com/ios/20150105/10829.html" target="_blank" rel="external">iOS-Core-Animation-Advanced-Techniques(五)</a>）</p>
<blockquote>
<p>它和kCAMediaTimingFunctionEaseInEaseOut很类似，但是加速和减速的过程都稍微有些慢。它和kCAMediaTimingFunctionEaseInEaseOut的区别很难察觉，可能是苹果觉得它对于隐式动画来说更适合（然后对UIKit就改变了想法，而是使用kCAMediaTimingFunctionEaseInEaseOut作为默认效果），虽然它的名字说是默认的，但还是要记住当创建显式的CAAnimation它并不是默认选项（换句话说，默认的图层行为动画用kCAMediaTimingFunctionDefault作为它们的计时方法）。</p>
</blockquote>
<p>如果不设置 <code>timingFunction</code> 属性，那么在使用 CA 的情况下， <code>timingFunction</code> 是 <code>kCAMediaTimingFunctionLinear</code> 的，而 POP 却是<code>kCAMediaTimingFunctionEaseOut</code> ，因此我们只要添加这么一行代码：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">popAnimation.timingFunction = <span class="string">[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]</span>;</div></pre></td></tr></table></figure>
<p>现在再看效果：</p>
<p><img src="http://img.blog.csdn.net/20151217114608713" alt="这里写图片描述"></p>
<p>可以看出来，在主线程没有阻塞的情况下，两种动画库的表现并无差异（POP 就是🐂）</p>
<p>现在我们来制造一点难度，人工利用线程的 sleep 增加一个主线程阻塞：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)repeatedlyBlockMainThread</div><div class="line">&#123;</div><div class="line">    NSLog(@<span class="string">"blocking main thread!"</span>);</div><div class="line">    [NSThread <span class="string">sleepForTimeInterval:</span><span class="number">0.25</span>];</div><div class="line">    [self <span class="string">performSelector:</span><span class="meta">@selector</span>(repeatedlyBlockMainThread) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再 <code>viewDidLoad</code> 里面调用 ：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(repeatedlyBlockMainThread) <span class="string">withObject:</span>nil <span class="string">afterDelay:</span><span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>现在再来看一下两者的动画效果：</p>
<p><img src="http://img.blog.csdn.net/20151217121603261" alt="这里写图片描述"></p>
<p>很明显，我们可以看出来，由于添加了主线程阻塞，利用 POP 制作的动画视图，在每隔 1s 都会卡顿一下，而 CA 的视图却完全不受主线程阻塞的影响。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次简单的对比，我们从工作机制上了解了 CA 和 POP 两个动画库的基本原理，并用简单的动画效果对比，重现了在主线程阻塞的情况下两者的差异，很显然， POP 受主线程阻塞的影响很大，在使用过程中，应避免在有可能发生主线程阻塞的情况下使用 POP ，避免制作卡顿的动画效果，产生不好的用户体验。文中提出了 POP 的这种缺点，但是 POP 毕竟是久经考验的动画技术，本人也正在学习中，有错误的地方吝请指正。</p>
<p>对比系列，是个人比较喜欢的一种学习方式，通过对比，找出不同技术的优缺点，可以更合理地使用这些武器，俗话说：好钢用在刀刃上，大抵如此。</p>
]]></content>
    
    <summary type="html">
    
      对比系列，是个人比较喜欢的一种学习方式，通过对比，找出不同技术的优缺点，可以更合理地使用这些武器，俗话说：好钢用在刀刃上，大抵如此。本文对 CoreAnimation 和 Facebook 的 POP 动画库进行了对比。
    
    </summary>
    
      <category term="Animation" scheme="http://lin493369.github.io/categories/Animation/"/>
    
    
      <category term="个人" scheme="http://lin493369.github.io/tags/%E4%B8%AA%E4%BA%BA/"/>
    
      <category term="POP" scheme="http://lin493369.github.io/tags/POP/"/>
    
      <category term="CoreAnimation" scheme="http://lin493369.github.io/tags/CoreAnimation/"/>
    
      <category term="Facebook" scheme="http://lin493369.github.io/tags/Facebook/"/>
    
  </entry>
  
  <entry>
    <title>UIAlertController 测试的修正</title>
    <link href="http://lin493369.github.io/2015/12/02/UIAlertController%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BF%AE%E6%AD%A3/"/>
    <id>http://lin493369.github.io/2015/12/02/UIAlertController测试的修正/</id>
    <published>2015-12-01T16:00:00.000Z</published>
    <updated>2017-04-13T03:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://swiftandpainless.com/correction-on-testing-uialertcontroller/" target="_blank" rel="external">http://swiftandpainless.com/correction-on-testing-uialertcontroller/</a><br>作者=dom<br>原文日期=2015/11/25</p>
<hr>
<p>两个月前，我曾发布了一篇<a href="http://swiftandpainless.com/how-to-test-uialertcontroller-in-swift/" target="_blank" rel="external"> 如何测试 UIAlertController </a>的文章。一个读者发现测试没有如期地起作用：</p>
<blockquote>
<p><a href="https://twitter.com/dasdom" target="_blank" rel="external">@dasdom</a> 你的测试是正常的，但是在 <code>MockUIAction</code> 中的简便 <code>init</code> 方法没有被调用。 你不能重写 <code>init</code> 方法，看起来像是 iOS 的bug。<br> — Larhythimx (@Larhythmix) <a href="https://twitter.com/Larhythmix/status/669456137041915905" target="_blank" rel="external">25. November 2015</a></p>
</blockquote>
<p>Larhythimx 说的完全正确。模拟程序的初始化方法从来没有调用。为什么我在写这个测试用例的时候没有发觉呢？那是因为 handler 确实被调用了，看起来就像 <code>UIAlertAction</code> 真的把 handler 作为内部变量去存储动作的 handler 闭包。这是非常脆弱的，并且 Larhythimx 在另一个 tweet 指出在他的测试程序中 handler 是 <code>nil</code>。</p>
<p>所以作为黄金通道（即编写不需要改变实现的测试）走不通，那就退而求其次用别的方法。</p>
<p>首先，我们在 <code>UIAlertAction</code> 中添加一个类方法去创建 action 。在 ViewController.swift 中增加如下扩展：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">extension</span> <span class="selector-tag">UIAlertAction</span> &#123;</div><div class="line">  <span class="selector-tag">class</span> <span class="selector-tag">func</span> <span class="selector-tag">makeActionWithTitle</span>(<span class="attribute">title</span>: String?, <span class="attribute">style</span>: UIAlertActionStyle, <span class="attribute">handler</span>: ((UIAlertAction) -&gt; Void)?) <span class="selector-tag">-</span>&gt; <span class="selector-tag">UIAlertAction</span> &#123;</div><div class="line">    <span class="selector-tag">return</span> <span class="selector-tag">UIAlertAction</span>(<span class="attribute">title</span>: title, <span class="attribute">style</span>: style, <span class="attribute">handler</span>: handler)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>MockAlertAction</code> 中增加这个重写方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">override</span> <span class="selector-tag">class</span> <span class="selector-tag">func</span> <span class="selector-tag">makeActionWithTitle</span>(<span class="attribute">title</span>: String?, <span class="attribute">style</span>: UIAlertActionStyle, <span class="attribute">handler</span>: ((UIAlertAction) -&gt; Void)?) <span class="selector-tag">-</span>&gt; <span class="selector-tag">MockAlertAction</span> &#123;</div><div class="line">  <span class="selector-tag">return</span> <span class="selector-tag">MockAlertAction</span>(<span class="attribute">title</span>: title, <span class="attribute">style</span>: style, <span class="attribute">handler</span>: handler)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实现代码中，我们现在可以使用类方法去创建 alert 动作：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> okAction = Action.makeActionWithTitle<span class="function"><span class="params">(<span class="string">"OK"</span>, style: .Default)</span> &#123; <span class="params">(action)</span> -&gt;</span> Void <span class="keyword">in</span></div><div class="line">    self.actionString = <span class="string">"OK"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> cancelAction = Action.makeActionWithTitle<span class="function"><span class="params">(<span class="string">"Cancel"</span>, style: .Default)</span> &#123; <span class="params">(action)</span> -&gt;</span> Void <span class="keyword">in</span></div><div class="line">    self.actionString = <span class="string">"Cancel"</span></div><div class="line">&#125;</div><div class="line">alertViewController.addAction(cancelAction)</div></pre></td></tr></table></figure>
<p>为了确保我们的测试用例正常，如我们预期地工作，将<code>MockAlertAction</code>的 <code>handler</code> 属性重命名为 <code>mockHandler</code>：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mockHandler: Handler?</div></pre></td></tr></table></figure></p>
<p>此外，我们为动作的模拟标题添加测试。为取消动作的测试应该像这样：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func testAlert_FirstActionStoresCancel() &#123;</div><div class="line">  sut<span class="selector-class">.Action</span> = MockAlertAction<span class="selector-class">.self</span></div><div class="line"></div><div class="line">  sut.showAlert(UIButton())</div><div class="line"></div><div class="line">  let alertController = sut<span class="selector-class">.presentedViewController</span> as! UIAlertController</div><div class="line">  let action = alertController<span class="selector-class">.actions</span><span class="selector-class">.first</span> as! MockAlertAction</div><div class="line">  action.mockHandler!(action)</div><div class="line"></div><div class="line">  XCTAssertEqual(sut<span class="selector-class">.actionString</span>, <span class="string">"Cancel"</span>)</div><div class="line">  XCTAssertEqual(action<span class="selector-class">.mockTitle</span>, <span class="string">"Cancel"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个测试在此前的版本将会失败，因为初始化方法没有被调用，因此模拟标题也没有得到设置。</p>
<p>你可以在 <a href="https://github.com/dasdom/TestingAlertExperiment" target="_blank" rel="external">github</a> 上找到正确的版本。</p>
<p>再次感谢 Larhythimx 的推特！</p>
]]></content>
    
    <summary type="html">
    
      首先，我们在 UIAlertAction 中添加一个类方法去创建 action 。在 ViewController.swift 中增加如下扩展：
    
    </summary>
    
      <category term="Swift" scheme="http://lin493369.github.io/categories/Swift/"/>
    
    
      <category term="test" scheme="http://lin493369.github.io/tags/test/"/>
    
      <category term="dom" scheme="http://lin493369.github.io/tags/dom/"/>
    
  </entry>
  
  <entry>
    <title>Xcode:用于管理多个 target 配置的 XCConfig 文件</title>
    <link href="http://lin493369.github.io/2015/11/24/Xcode-%E7%94%A8%E4%BA%8E%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAtarget%E9%85%8D%E7%BD%AE%E7%9A%84XCConfig%E6%96%87%E4%BB%B6/"/>
    <id>http://lin493369.github.io/2015/11/24/Xcode-用于管理多个target配置的XCConfig文件/</id>
    <published>2015-11-23T16:00:00.000Z</published>
    <updated>2017-04-13T03:33:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接:<br><a href="http://szulctomasz.com/xcode-xcconfig-files-for-managing-targets-configurations/" target="_blank" rel="external">http://szulctomasz.com/xcode-xcconfig-files-for-managing-targets-configurations/</a><br>作者:<br>Tomasz Szulc<br>原文日期:<br>2015/11/14</p>
<hr>
<p>让我们来看看 XCConfig 文件如何才能在多个拥有不同配置的 target 中良好地工作。</p>
<p>今天我本计划学习一些新东西，因此我搜索了 <a href="https://github.com/mozilla/firefox-ios" target="_blank" rel="external">mozilla/firefox-ios</a> 库（译者：这是在火狐浏览器在 github 的一个开源项目）的相关信息，接着我发现他们会在项目中使用大量的配置文件。</p>
<p>我曾经在几个项目中使用 XCConfig ，但是我并没有在现在开发的项目中使用它。因为这个项目有多个不同配置的 target，因此我开始思考如何才能有效且简单地管理这些 target 。</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>这个项目现在已经被我的团队接手了。客户的团队先开发了大约一年半的时间，最后决定将项目完全外包出去。这个项目一个麻烦的事就是 target 有不同的配置，因此如何更好地解决，是个棘手的问题。</p>
<p>项目由十个应用 target 组成，两个总的 target 做些业务，以及一个测试 target 。每一个 target 使用不同的尾部和不同的 “api keys”，以及其他像用于hockeyapp（HockeyApp 是一个用来分发你的程序并收集应用的崩溃报告的收集框架，类似友盟） token 的键（key）。每一个 target 有自己的预处理宏，如：“TARGET_A”, “TARGET_B”等…（虚构的名字）。然后，token，api keys，后端的 url 被存储在 plist 文件中。因此很自然地，就需要一些类来封装这个文件，并且有语法分析程序以及可以提供给我们适当的键。这个类有超过两百行的代码，对我来说，仅仅阅读这些数据就要花费很多时间。</p>
<p>因此，我想可能可以使用 XCConfig 文件来简化和替代使用语法分析程序和十个个预处理宏（一个 target）去决定从 plist 文件应该返回什么值。你可以在下面找到我的解决方案。可能不是最好的方案，但是此刻应该是最好的。如果你有更好的方案，我很愿意去拜读 :)</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>核心思想是使用一些有层级的配置文件。第一层是用于存储最普通的数据，第二层用于区分debug和release模式，最后一层用于关联特殊 target 的设置。</p>
<p><img src="http://szulctomasz.com/wp-content/uploads/2015/11/diagram_1.png" alt="这里写图片描述"></p>
<h2 id="Common-xcconfig"><a href="#Common-xcconfig" class="headerlink" title="Common.xcconfig"></a>Common.xcconfig</h2><p>这个文件存储着类似应用名称，应用版本，bundle version，以及其他 debug和 release target 中通用的常见配置。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Common.xcconfig</span></div><div class="line"><span class="comment">//  &lt;truncated&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line">APP_NAME = App</div><div class="line">APP_VERSION = <span class="number">1.6</span></div><div class="line">APP_BUNDLE_ID = <span class="number">153</span></div></pre></td></tr></table></figure>
<p>考虑到为十个 target 改变相应的应用版本和 bundle 可能会消耗很多时间。其他的选项可能会创建聚合的 target ，这样可以在每次 Cmd+B的时候更新Info-plist 文件，但是我会避免这样的情况并且让项目不会比现在更复杂。</p>
<h2 id="Common-debug-和-Common-release"><a href="#Common-debug-和-Common-release" class="headerlink" title="Common.debug 和 Common.release"></a>Common.debug 和 Common.release</h2><p>这个文件能够存储可用于debug和release target的最常用配置。文件包含Common.xcconfig并且能够重写它的变量。如：你可以通过重写一个变量，轻易地把每个debug target 的应用名称改为“App Debug”。对于存储常见的用于开发和发行版本target的 API Key，这里也是很好的地方。</p>
<p><strong><em>提示：使用通用配置文件和 CocoaPods</em></strong></p>
<p>如果你使用 CocoaPods，你应该相应地在你的配置文件之一中包括（include）Pods.debug.xcconfig 或者 Pods.release.xcconfig。我推荐先在项目信息标签中设置你的配置文件然后执行 <code>pod install</code>去让Pod 项目重新配置。在安装之后，你应该及时地把 Pod 配置文件中的其中一个包括（include）到你自己的文件中去。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error:</div><div class="line">[!] CocoaPods did not <span class="keyword">set</span> the base configuration <span class="keyword">of</span> your <span class="keyword">project</span> because your <span class="keyword">project</span> already has a custom config set. <span class="keyword">In</span> <span class="keyword">order</span> <span class="keyword">for</span> CocoaPods integration <span class="keyword">to</span> <span class="keyword">work</span> <span class="keyword">at</span> all, please either <span class="keyword">set</span> the base configurations <span class="keyword">of</span> the target TARGET_NAME <span class="keyword">to</span> Pods/Target Support Files/Pods/Pods.debug.xcconfig <span class="keyword">or</span> <span class="keyword">include</span> the Pods/Target Support Files/Pods/Pods.debug.xcconfig <span class="keyword">in</span> your <span class="keyword">build</span> configuration.</div></pre></td></tr></table></figure>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Common.debug.xcconfig</span></div><div class="line"><span class="comment">//  &lt;truncated&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Common.xcconfig"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Pods/Target Support Files/Pods/Pods.debug.xcconfig"</span></span></div><div class="line"></div><div class="line">APP_NAME = App <span class="keyword">Debug</span></div><div class="line">API_KEY_A = API_KEY_HERE</div><div class="line">API_KEY_B = API_KEY_HERE</div></pre></td></tr></table></figure>
<h2 id="PerTarget-xcconfig"><a href="#PerTarget-xcconfig" class="headerlink" title="PerTarget.xcconfig"></a>PerTarget.xcconfig</h2><p>我确实不需要在这个层级使用 debug/release 配置文件（因为项目中的其他遗留问题），所以我只是用包括适当的 Common.debug.xcconfig 或者 Common.release.xcconfig 的  PerTarget.xcconfig 文件。但是最好应该有 debug 和 release 配置文件。在这个层级，你可以配置关联到特殊 target 的东西。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Develop.xcconfig</span></div><div class="line"><span class="comment">//  &lt;truncated&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="selector-id">#include</span> <span class="string">"Common.debug.xcconfig"</span></div><div class="line"></div><div class="line">BACKEND_URL = http:\/\/develop<span class="selector-class">.api</span><span class="selector-class">.szulctomasz</span><span class="selector-class">.com</span></div><div class="line">SOME_KEY_A = VALUE_HERE</div><div class="line">SOME_KEY_B = VALUE_HERE</div></pre></td></tr></table></figure>
<h2 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h2><p>所有的配置文件被存储了。现在是时候去使用他们了。像我例子中有这么多的target，我可以把 Info.plist 文件的数量减少到只有一个，由于所有的不同的地方都已经在 xcconfig 文件中了，所以这一个文件可以替代多个文件。</p>
<p>你可以看到在你通过这些配置文件构建应用之后，有一些值出现在项目的 Build Setting 的 “User-Defined”部分。</p>
<p>如果你想要使用配置文件中的变量，例如，在一个target的 Info.plist 文件中，你需要使用这种写法：<code>$(VARIABLE)</code>。使用这种方式，你可以设置“Bundle Identifier”, “Bundle name”, “Bundle version”以及其他你想要配置的事项。</p>
<p>在代码中访问其他变量看起来有点不一样，我发现最简单的方法就是在 Info.plist 中创建附加的区域，通过使用相同的变量名称和使用上述的写法去设置值。这样你就可以在你的代码中读到这些值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> dictionary = <span class="type">NSBundle</span>.mainBundle().infoDictionary &#123;</div><div class="line">    <span class="keyword">let</span> appName = dictionary[<span class="string">"APP_NAME"</span>] <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> appVersion = dictionary[<span class="string">"APP_VERSION"</span>] <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> appBuildVersion = dictionary[<span class="string">"APP_BUILD_VERSION"</span>] <span class="keyword">as</span>! <span class="type">String</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(appName)</span> <span class="subst">\(appVersion)</span> (<span class="subst">\(appBuildVersion)</span>)"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">let</span> backend = (dictionary[<span class="string">"BACKEND_URL"</span>] <span class="keyword">as</span>! <span class="type">String</span>).stringByReplacingOccurrencesOfString(<span class="string">"\\"</span>, withString: <span class="string">""</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"backend: <span class="subst">\(backend)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是 <a href="https://github.com/tomkowz/demo-xcconfig" target="_blank" rel="external">tomkowz/demo-xcconfig</a> 的代码，从里面你可以看到一些使用 xcconfig 文件的例子。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Xcode 配置文件给出了配置 target 的简易方式，并且支持方便地维护项目配置。在我用例中，可以很棒地切换到这些文件，因为现在维护项目配置和我没有使用这个解决方案之前比起来简单了很多。</p>
]]></content>
    
    <summary type="html">
    
      让我们来看看 XCConfig 文件如何才能在多个拥有不同配置的 target 中良好地工作。
    
    </summary>
    
      <category term="Swift" scheme="http://lin493369.github.io/categories/Swift/"/>
    
    
      <category term="Tomasz Szulc" scheme="http://lin493369.github.io/tags/Tomasz-Szulc/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的函数式编程</title>
    <link href="http://lin493369.github.io/2015/11/16/Swift%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://lin493369.github.io/2015/11/16/Swift中的函数式编程/</id>
    <published>2015-11-15T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://natashatherobot.com/functional-programming-in-swift/" target="_blank" rel="external">http://natashatherobot.com/functional-programming-in-swift/</a><br>作者=Natasha The Robot<br>原文日期=2015/11/13</p>
<hr>
<p>Swift 一个强有力的语言特性就是能够用多样的函数式风格去编写代码。这在社区中看起来非常地激动人心。</p>
<p>我在去年年底花费了一些时间学习函数式编程，所以我可以写更好的 Swift 代码。因此，我非常推荐你们也花时间去学习一下！</p>
<p>另外，我非常推荐推荐你们去看 <a href="http://2014.funswiftconf.com/" target="_blank" rel="external">Functional Swift conference</a>上的每一个视频。</p>
<p>所以在花了这么多时间后，我想要总结一下个人有关于函数式编程在 Swift 应用的一些思考。</p>
<h2 id="跟着概念走"><a href="#跟着概念走" class="headerlink" title="跟着概念走"></a>跟着概念走</h2><p>函数式编程是令人生畏的，这要归咎于单子（monads）和 函数子（functors）！然而，一旦你领悟了它的核心概念，那么函数式编程的思想会超级简单：</p>
<blockquote>
<p>“函数式编程是一个编程范例…它把计算作为数学函数的评估，并避免改变状态和可变数据。”— <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>所以核心就是你应该用数学的方式去编写代码。你的函数应该有清晰的输入和输出，并且不会像可变对象一样有全局副作用。这就是了！</p>
<h2 id="避免可变状态"><a href="#避免可变状态" class="headerlink" title="避免可变状态"></a>避免可变状态</h2><p>这和上述的注意点类似。函数式编程要编写的是没有副作用的数学代码。</p>
<p>在 Swift 中使用结构体和协议帮助你避免可变状态。</p>
<p>我极度推荐观看 <a href="https://twitter.com/andy_matuschak" target="_blank" rel="external">@andy_matuschak</a>的  <a href="https://realm.io/news/andy-matuschak-controlling-complexity/" target="_blank" rel="external">Controlling Complexity in Swift</a>，这可以让你理解如何去实现以及最终的代码会如何地强大。</p>
<h2 id="可读性第一"><a href="#可读性第一" class="headerlink" title="可读性第一"></a>可读性第一</h2><p>我发现很多高级的函数式代码，通常由于五个以上的习惯性编程而变得特别难以阅读。如果你遵从函数式编程的概念，有很多方法让你的代码变得更清楚。</p>
<p>但是在今天结束之前，还要多说一句，如果你在一个团队中工作，最重要的事就是让代码可读性更强。如果一个内部或者一个新的开发者加入你们的团队，他们会不会完全迷失了？如果你专注于编写易读的代码（取代好玩和花哨的写法），他们可能会很快就有产出。</p>
<p>记住一点，可读性的优先级永远比花哨的代码高（除非你的目标就是用一个好玩的副作用去实现好玩和花哨的程序）。</p>
<h2 id="不要和-framework-作对"><a href="#不要和-framework-作对" class="headerlink" title="不要和 framework 作对"></a>不要和 framework 作对</h2><p>当然，在 iOS 编程中，由于 Cocoa framework 的建立和用户的输入输出，没有副作用显然是不可能的（在纯粹的数学世界，确实存在完全没有外部副作用，但那不是我们生活的世界！）。</p>
<p>例如，如果你创建了一个通用的转换器（formatter）（例如货币转换器），并用在代码中的一些地方，用单例是一个很好的方法。你还必须为UI Layer 使用 <code>UIViewControllers</code> 以及 <code>UIViews</code>。总有办法去脱离你的逻辑，进而让很好的不可变组件去帮助你可变化这些东西，但是不要过火地把 freamwork 改变为面目全非（可读，不可读）的状态。</p>
<h2 id="学习高阶的函数式编程"><a href="#学习高阶的函数式编程" class="headerlink" title="学习高阶的函数式编程"></a>学习高阶的函数式编程</h2><p>再次强调，你不应该执着于在你的 Swift 代码中使用花哨的技巧（除非你只是为了试验、或者好玩）。我非常推荐学习极限的函数式编程，以此来理解高级的概念，并且要找出 Swift 中的函数式代码行。</p>
<p>开始先花一些时间阅读 <a href="https://www.objc.io/books/fpinswift/" target="_blank" rel="external">Functional Programming in Swift</a> ！这里有<a href="http://natashatherobot.com/reading-functional-programming/" target="_blank" rel="external">更多的资源</a>去帮助你开始学习！</p>
]]></content>
    
    <summary type="html">
    
      Swift 一个强有力的语言特性就是能够用多样的函数式风格去编写代码。这在社区中看起来非常地激动人心。
    
    </summary>
    
      <category term="Swift" scheme="http://lin493369.github.io/categories/Swift/"/>
    
    
      <category term="Natasha The Robot" scheme="http://lin493369.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="函数式编程" scheme="http://lin493369.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>让我们来搞崩 Cocoa 吧（黑暗代码）</title>
    <link href="http://lin493369.github.io/2015/11/10/%E8%AE%A9%E6%88%91%E4%BB%AC%E6%90%9E%E5%B4%A9cocoa/"/>
    <id>http://lin493369.github.io/2015/11/10/让我们搞崩cocoa/</id>
    <published>2015-11-09T16:00:00.000Z</published>
    <updated>2017-04-13T03:30:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="https://mikeash.com/pyblog/friday-qa-2014-01-10-lets-break-cocoa.html" target="_blank" rel="external">https://mikeash.com/pyblog/friday-qa-2014-01-10-lets-break-cocoa.html</a><br>作者=Mikeash<br>原文日期=2014/01/10</p>
<hr>
<p>译者：在传统的文章中，我们一直致力于如何编写高效稳定的代码，努力提高代码的鲁棒性。然而在本文中，我们将会改变一下思维方式，采用破坏的方式去挖掘 Cocoa 的一些特性，虽然文中作者表现出一种“病态”的破坏心理，但正因为有这种精神，通过文中那些黑暗代码，可以让我们更加深刻地理解 Cocoa 。</p>
<hr>
<p><a href="https://mikeash.com/pyblog/?tag=letsbuild" target="_blank" rel="external">让我们编写系列</a>文章是这个博客中我最喜欢的部分。但是，有时候搞崩程序比编写他们更有趣。现在，我将要开发一些好玩且不同寻常的方式去让 Cocoa 崩溃。</p>
<h2 id="带有-NUL-的字符串"><a href="#带有-NUL-的字符串" class="headerlink" title="带有 NUL 的字符串"></a>带有 NUL 的字符串</h2><p>NUL（译者：应该为 ‘\0’） 字符在 ASCII 和 Unicode 中代表 0，是一个不寻常的麻烦鬼。当在 C 字符串中时，它不作为一个字符，而是一个代表字符串结束的标识符。在其他的上下文环境中，它就会跟其他字符一样了。</p>
<p>当你混合 C 字符串和其它上下文环境，就会产生很有趣的结果。例如：<code>NSString</code> 对象，使用 NUL 字符毫无问题：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *s = @<span class="string">"abc\0def"</span><span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果我们认真的话，我们可以使用 lldb 打印它：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) p (void)<span class="string">[[NSFileHandle fileHandleWithStandardOutput] writeData: [s dataUsingEncoding: 5]]</span></div><div class="line">abcdef</div></pre></td></tr></table></figure></p>
<p>然而，展示这个字符串更为典型的方式是，字符串被当做 C 字符串在某个点结束。由于 ‘\0’ 字符意味着 C 字符串的结尾，因此字符串会在转换时缩短：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">po</span> s</div><div class="line"><span class="keyword">abc</span></div><div class="line">(lldb) <span class="keyword">p</span> (void)NSLog(s)</div><div class="line">LetsBreakCocoa[<span class="number">16689</span>:<span class="number">303</span>] <span class="keyword">abc</span></div></pre></td></tr></table></figure></p>
<p>原始的字符已然包含预计的字符数量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) p [s length]</div><div class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) $<span class="number">1</span> = <span class="number">7</span></div></pre></td></tr></table></figure></p>
<p>试图对这个字符串进行操作会让你真正感到困惑：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">po</span> [s stringByAppendingPathExtension: @<span class="string">"txt"</span>]</div><div class="line"><span class="keyword">abc</span></div></pre></td></tr></table></figure></p>
<p>如果你不知道字符串的中间包含一个 NUL ，这类问题会让你感到这个世界满满的恶意。</p>
<p>一般来说，你不会遇到 NUL 字符，但是它很有可能通过加载外部资源的数据进来。<code>-initWithData:encoding:</code> 会很轻易地读入零比特并且在返回的 <code>NSString</code> 中产生 NUL 字符。</p>
<h2 id="循环容器"><a href="#循环容器" class="headerlink" title="循环容器"></a>循环容器</h2><p>这里有一个数组：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *a = [<span class="built_in">NSMutableArray</span> array];</div></pre></td></tr></table></figure>
<p>这里有一个数组包含其他的数据：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *a = [NSMutableArray array]<span class="comment">;</span></div><div class="line">   NSMutableArray *<span class="keyword">b </span>= [NSMutableArray array]<span class="comment">;</span></div><div class="line">   [a <span class="keyword">addObject: </span><span class="keyword">b];</span></div></pre></td></tr></table></figure></p>
<p>目前为止，看起来还不错。现在我们让一个数组包含自身：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *a = [NSMutableArray array]<span class="comment">;</span></div><div class="line">[a <span class="keyword">addObject: </span>a]<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>猜猜会打印出什么？</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSLog(<span class="meta">@"%</span><span class="meta">@",</span> a);</div></pre></td></tr></table></figure>
<p>以下就是调用堆栈的信息（译者：bt 命令为打印调用堆栈的信息）：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">   (<span class="keyword">lldb) </span><span class="keyword">bt</span></div><div class="line">* thread <span class="comment">#1: tid = 0x43eca, 0x00007fff8952815a CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 154, queue = 'com.apple.main-thread, stop reason = EXC_BAD_ACCESS (code=2, address=0x7fff5f3ffff8)</span></div><div class="line">                   frame <span class="comment">#0: 0x00007fff8952815a CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 154</span></div><div class="line">                   frame <span class="comment">#1: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#2: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#3: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#4: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#5: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#6: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#7: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#8: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#9: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#10: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div><div class="line">                   frame <span class="comment">#11: 0x00007fff895282da CoreFoundation`-[NSArray descriptionWithLocale:indent:] + 538</span></div></pre></td></tr></table></figure></p>
<p>这里还删除了上千个栈帧。描述方法无法处理递归容器，所以它持续尝试去追踪到“树”的结束，并最终发生异常。</p>
<p>我们可以用它跟自身比较对等性：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"%d"</span>, [a <span class="attribute">isEqual</span>: a]);</div></pre></td></tr></table></figure>
<p>这姑且看起来是 YES。让我们创造另一个结构上相同的数组 b 然后用 a 和它比较：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *<span class="keyword">b </span>= [NSMutableArray array]<span class="comment">;</span></div><div class="line">   [<span class="keyword">b </span><span class="keyword">addObject: </span><span class="keyword">b];</span></div><div class="line">   NSLog(@<span class="string">"%d"</span>, [a isEqual: <span class="keyword">b]);</span></div></pre></td></tr></table></figure>
<p>很抱歉：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">lldb) </span><span class="keyword">bt</span></div><div class="line">* thread <span class="comment">#1: tid = 0x4412a, 0x00007fff8946a8d7 CoreFoundation`-[NSArray isEqualToArray:] + 103, queue = 'com.apple.main-thread, stop reason = EXC_BAD_ACCESS (code=2, address=0x7fff5f3fff28)</span></div><div class="line">                frame <span class="comment">#0: 0x00007fff8946a8d7 CoreFoundation`-[NSArray isEqualToArray:] + 103</span></div><div class="line">                frame <span class="comment">#1: 0x00007fff8946f6b7 CoreFoundation`-[NSArray isEqual:] + 71</span></div><div class="line">                frame <span class="comment">#2: 0x00007fff8946aa07 CoreFoundation`-[NSArray isEqualToArray:] + 407</span></div><div class="line">                frame <span class="comment">#3: 0x00007fff8946f6b7 CoreFoundation`-[NSArray isEqual:] + 71</span></div><div class="line">                frame <span class="comment">#4: 0x00007fff8946aa07 CoreFoundation`-[NSArray isEqualToArray:] + 407</span></div><div class="line">                frame <span class="comment">#5: 0x00007fff8946f6b7 CoreFoundation`-[NSArray isEqual:] + 71</span></div><div class="line">                frame <span class="comment">#6: 0x00007fff8946aa07 CoreFoundation`-[NSArray isEqualToArray:] + 407</span></div><div class="line">                frame <span class="comment">#7: 0x00007fff8946f6b7 CoreFoundation`-[NSArray isEqual:] + 71</span></div><div class="line">                frame <span class="comment">#8: 0x00007fff8946aa07 CoreFoundation`-[NSArray isEqualToArray:] + 407</span></div><div class="line">                frame <span class="comment">#9: 0x00007fff8946f6b7 CoreFoundation`-[NSArray isEqual:] + 71</span></div></pre></td></tr></table></figure>
<p>对等性检查同样也不知道如何处理递归容易。</p>
<h2 id="循环视图"><a href="#循环视图" class="headerlink" title="循环视图"></a>循环视图</h2><p>你可以用<code>NSView</code>实例做同样的实验：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSWindow *win = <span class="comment">[self window]</span>;</div><div class="line">NSView *a = <span class="comment">[<span class="comment">[NSView alloc]</span> initWithFrame: NSMakeRect(0, 0, 1, 1)]</span>;</div><div class="line"><span class="comment">[a addSubview: a]</span>;</div><div class="line"><span class="comment">[<span class="comment">[win contentView]</span> addSubview: a]</span>;</div></pre></td></tr></table></figure></p>
<p>为了让这个程序崩溃，你只需要尝试去显示视窗。你甚至不需要去打印一个描述或者做对等性比较。当试图去显示视窗时，应用就会由于尝试去追踪底部的视图结构而崩溃。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">lldb) </span><span class="keyword">bt</span></div><div class="line"> * thread <span class="comment">#1: tid = 0x458bf, 0x00007fff8c972528 AppKit`NSViewGetVisibleRect + 130, queue = 'com.apple.main-thread, stop reason = EXC_BAD_ACCESS (code=2, address=0x7fff5f3ffff8)</span></div><div class="line">                 frame <span class="comment">#0: 0x00007fff8c972528 AppKit`NSViewGetVisibleRect + 130</span></div><div class="line">                 frame <span class="comment">#1: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#2: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#3: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#4: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#5: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#6: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#7: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#8: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#9: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#10: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#11: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#12: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#13: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#14: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#15: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#16: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#17: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#18: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#19: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div><div class="line">                 frame <span class="comment">#20: 0x00007fff8c9725c6 AppKit`NSViewGetVisibleRect + 288</span></div></pre></td></tr></table></figure></p>
<p>Hash Abuse</p>
<h2 id="滥用-Hash"><a href="#滥用-Hash" class="headerlink" title="滥用 Hash"></a>滥用 Hash</h2><p>让我们创建一个实例一直等于其他类的类 AlwaysEqual，但是 hash 值并不一样：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">AlwaysEqual </span>: NSObject <span class="variable">@end</span></div><div class="line"><span class="variable">@implementation</span> AlwaysEqual</div><div class="line"></div><div class="line">- (BOOL)<span class="attribute">isEqual</span>: (id)object &#123; <span class="selector-tag">return</span> <span class="selector-tag">YES</span>; &#125;</div><div class="line"><span class="selector-tag">-</span> (NSUInteger)<span class="selector-tag">hash</span> &#123; <span class="selector-tag">return</span> <span class="selector-tag">random</span>(); &#125;</div><div class="line"></div><div class="line">@<span class="selector-tag">end</span></div></pre></td></tr></table></figure></p>
<p>这显然违反了 Cocoa 的要求，当两个对象被认为是相等时，他们的 hash 应该总是返回相等的值。当然，这不是非常严格的强制要求，所以上述代码依然可以编译和运行。</p>
<p>让我们添加一个实例到 <code>NSMutableSet</code> 中：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *<span class="keyword">set</span> = [NSMutableSet <span class="comment">set]</span>;</div><div class="line"><span class="keyword">for</span>(;;)</div><div class="line">&#123;</div><div class="line">    AlwaysEqual *obj = [[AlwaysEqual alloc] init];</div><div class="line">    [<span class="keyword">set</span> addObject: obj];</div><div class="line">    NSLog(@<span class="string">"%@"</span>, <span class="keyword">set</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这产生了一个有趣的日志：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">LetsBreakCocoa[17069:303] &#123;(</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ed70</span>&gt;</span></div><div class="line">)&#125;</div><div class="line">LetsBreakCocoa[17069:303] &#123;(</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ec40</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ed70</span>&gt;</span></div><div class="line">)&#125;</div><div class="line">LetsBreakCocoa[17069:303] &#123;(</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ec40</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ed70</span>&gt;</span></div><div class="line">)&#125;</div><div class="line">LetsBreakCocoa[17069:303] &#123;(</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ec40</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ed70</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001f930</span>&gt;</span></div><div class="line">)&#125;</div><div class="line">LetsBreakCocoa[17069:303] &#123;(</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ec40</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ed70</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001f930</span>&gt;</span></div><div class="line">)&#125;</div><div class="line">LetsBreakCocoa[17069:303] &#123;(</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ec40</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001ed70</span>&gt;</span>,</div><div class="line">                <span class="tag">&lt;<span class="name">AlwaysEqual:</span> <span class="attr">0x61000001f930</span>&gt;</span></div><div class="line">)&#125;</div></pre></td></tr></table></figure></p>
<p>每次运行都不能保证一样，但是综合看起来就是这样。<code>addObject:</code>通常先添加一个新对象，然后在更多的对象添加进来的时候很少成功，最后顶部只有三个对象。现在这个集合包含三个看起来是独一无二的对象，而且看起来应该不会包含更多的对象了。所以，在重写 <code>isEqual:</code> 时总是应该重写 <code>hash</code>方法。</p>
<h2 id="滥用-Selector"><a href="#滥用-Selector" class="headerlink" title="滥用 Selector"></a>滥用 Selector</h2><p>Selector 是一个特殊的数据类型，在运行期用于表示方法名。在我们习惯中，它们必须是独一无二的字符串，尽管它们并不是严格地要求是字符串。在现在的 Objective-C  运行期，它们是字符串，并且我们都知道利用 Selector 去搞崩程序是很好玩儿的事。</p>
<p>马上行动，下面就是一个例子：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SEL </span><span class="keyword">sel </span>= (<span class="keyword">SEL)"";</span></div><div class="line">[NSObject performSelector: <span class="keyword">sel];</span></div></pre></td></tr></table></figure></p>
<p>当编译和运行之后，在运行期产生了很令人费解的错误：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LetsBreakCocoa[<span class="number">17192</span>:<span class="number">303</span>] *** NSForwarding: warning: <span class="keyword">selector</span> (<span class="number">0</span>x100001f86) <span class="keyword">for</span> message <span class="string">''</span> does <span class="keyword">not</span> match <span class="keyword">selector</span> known <span class="keyword">to</span> Objective C runtime (<span class="number">0</span>x6100000181f0)-- abort</div><div class="line">LetsBreakCocoa[<span class="number">17192</span>:<span class="number">303</span>] +[NSObject ]: unrecognized <span class="keyword">selector</span> sent <span class="keyword">to</span> <span class="keyword">class</span> <span class="number">0</span>x7fff75570810</div></pre></td></tr></table></figure>
<p>通过创建奇怪的 selector，会产生真正奇怪的错误：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SEL sel = (SEL)<span class="string">"]: unrecognized selector sent to class 0x7fff75570810"</span>;</div><div class="line">[NSObject performSelector: sel];</div><div class="line"></div><div class="line">LetsBreakCocoa[<span class="number">17262</span>:<span class="number">303</span>] +[NSObject ]: unrecognized selector sent <span class="keyword">to</span> <span class="built_in">class</span> <span class="number">0x7fff75570810</span>]: unrecognized selector sent <span class="keyword">to</span> <span class="built_in">class</span> <span class="number">0x7fff75570810</span></div></pre></td></tr></table></figure>
<p>你甚至让错误看起来像是停止响应完整信息的 NSObject ：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SEL sel = (SEL)<span class="string">"alloc"</span>;</div><div class="line">[NSObject performSelector: sel];</div><div class="line"></div><div class="line">LetsBreakCocoa[<span class="number">46958</span>:<span class="number">303</span>] *** NSForwarding: warning: selector (<span class="number">0x100001f77</span>) <span class="keyword">for</span> message 'alloc' <span class="keyword">does</span> <span class="keyword">not</span> match selector known <span class="keyword">to</span> Objective C runtime (<span class="number">0x7fff8d38d879</span>)<span class="comment">-- abort</span></div><div class="line">LetsBreakCocoa[<span class="number">46958</span>:<span class="number">303</span>] +[NSObject alloc]: unrecognized selector sent <span class="keyword">to</span> <span class="built_in">class</span> <span class="number">0x7fff75570810</span></div></pre></td></tr></table></figure></p>
<p>显然，这不是真正的 alloc selector，它是一个碰巧指向一个包含 “alloc” 字符串的伪装 selector。但是，runtime 依然把它打印为 alloc 。</p>
<h2 id="伪造对象"><a href="#伪造对象" class="headerlink" title="伪造对象"></a>伪造对象</h2><p>虽然现在越来越复杂，但是 Objective-C 依然是分配给所有对象类的大内存中的一小块内存。在这样的思维下，我们就可以创造一个伪造对象：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = (__bridge <span class="keyword">id</span>)(<span class="keyword">void</span> *)&amp;(Class)&#123; [<span class="built_in">NSObject</span> <span class="keyword">class</span>] &#125;;</div></pre></td></tr></table></figure></p>
<p>这些伪造对象也完全能工作：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = (__bridge <span class="keyword">id</span>)(<span class="keyword">void</span> *)&amp;(Class)&#123; [<span class="built_in">NSObject</span> <span class="keyword">class</span>] &#125;;</div><div class="line">    [array addObject: obj];</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, array);</div></pre></td></tr></table></figure></p>
<p>上述代码不仅可以运行并且打印日志如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">LetsBreakCocoa</span><span class="selector-attr">[17543:303]</span> (</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span>,</div><div class="line">       <span class="string">"&lt;NSObject: 0x7fff5fbfe760&gt;"</span></div><div class="line">   )</div></pre></td></tr></table></figure></p>
<p>可惜的是，看起来所有伪造对象都是以同样的地址结束的。但是还是可以继续工作的。好了，当你退出方法并且 autorelease pool 试图去清理时：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">lldb) </span><span class="keyword">bt</span></div><div class="line">* thread <span class="comment">#1: tid = 0x46790, 0x00007fff8b3d55c9 libobjc.A.dylib`realizeClass(objc_class*) + 156, queue = 'com.apple.main-thread, stop reason = EXC_BAD_ACCESS (code=1, address=0x7fff00006000)</span></div><div class="line">    frame <span class="comment">#0: 0x00007fff8b3d55c9 libobjc.A.dylib`realizeClass(objc_class*) + 156</span></div><div class="line">    frame <span class="comment">#1: 0x00007fff8b3d820c libobjc.A.dylib`lookUpImpOrForward + 98</span></div><div class="line">    frame <span class="comment">#2: 0x00007fff8b3cb169 libobjc.A.dylib`objc_msgSend + 233</span></div><div class="line">    frame <span class="comment">#3: 0x00007fff8940186f CoreFoundation`CFRelease + 591</span></div><div class="line">    frame <span class="comment">#4: 0x00007fff89414ad9 CoreFoundation`-[__NSArrayM dealloc] + 185</span></div><div class="line">    frame <span class="comment">#5: 0x00007fff8b3cd65a libobjc.A.dylib`(anonymous namespace)::AutoreleasePoolPage::pop(void*) + 502</span></div><div class="line">    frame <span class="comment">#6: 0x00007fff89420d72 CoreFoundation`_CFAutoreleasePoolPop + 50</span></div><div class="line">    frame <span class="comment">#7: 0x00007fff8551ada7 Foundation`-[NSAutoreleasePool drain] + 147</span></div></pre></td></tr></table></figure></p>
<p>因为这些伪造对象没有合适分配内存，所以一旦autorelease pool 试图在方法返回时去操作它们，就会出现严重的错误，并且内存会被重写。</p>
<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>下面是一个类数组：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *classes = @[</div><div class="line">      [<span class="built_in">NSObject</span> <span class="keyword">class</span>],</div><div class="line">      [<span class="built_in">NSString</span> <span class="keyword">class</span>],</div><div class="line">      [<span class="built_in">NSView</span> <span class="keyword">class</span>]</div><div class="line">  ];</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, classes);</div><div class="line">  LetsBreakCocoa[<span class="number">17726</span>:<span class="number">303</span>] (</div><div class="line">      <span class="built_in">NSObject</span>,</div><div class="line">      <span class="built_in">NSString</span>,</div><div class="line">      <span class="built_in">NSView</span></div><div class="line">  )</div></pre></td></tr></table></figure></p>
<p>下面一个这些类实例的数组：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *<span class="keyword">instances </span>= [classes valueForKeyPath: @<span class="string">"alloc.init.autorelease"</span>]<span class="comment">;</span></div><div class="line">NSLog(@<span class="string">"%@"</span>, <span class="keyword">instances);</span></div><div class="line">LetsBreakCocoa[<span class="number">17726</span>:<span class="number">303</span>] (</div><div class="line">    <span class="string">"&lt;NSObject: 0x61000000a600&gt;"</span>,</div><div class="line">    <span class="string">""</span>,</div><div class="line">    <span class="string">"&lt;NSView: 0x610000136bc0&gt;"</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>键值编码并不意味着要这样使用，但是看起来也可以正常运行。</p>
<h2 id="调用者检查"><a href="#调用者检查" class="headerlink" title="调用者检查"></a>调用者检查</h2><p>编译器的 <code>builtin __builtin_return_address</code> 方法可以返回调用你的代码的地址：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *addr = <span class="number">__</span>builtin<span class="number">_</span><span class="keyword">return</span><span class="number">_</span>address(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>因此，我们可以获取调用者的信息，包括它的名字：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Dl_info</span> <span class="meta">info</span><span class="comment">;</span></div><div class="line"><span class="symbol">dladdr</span>(<span class="keyword">addr, </span>&amp;<span class="meta">info</span>)<span class="comment">;</span></div><div class="line"><span class="symbol">NSString</span> *callerName = [NSString <span class="keyword">stringWithUTF8String: </span><span class="meta">info</span>.dli_sname]<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>通过这个，我们可以做一些穷凶极恶的事（译者：并不认为是穷凶极恶的事，反而可作为调用动态方法的一种可选方法，虽然并不可靠），比如说完全可以根据不同的调用者调用合适的方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CallerInspection</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></div><div class="line"> <span class="class"><span class="keyword">@implementation</span> <span class="title">CallerInspection</span></span></div><div class="line"></div><div class="line"> - (<span class="keyword">void</span>)method</div><div class="line"> &#123;</div><div class="line">     <span class="keyword">void</span> *addr = __builtin_return_address(<span class="number">0</span>);</div><div class="line">     Dl_info info;</div><div class="line">     dladdr(addr, &amp;info);</div><div class="line">     <span class="built_in">NSString</span> *callerName = [<span class="built_in">NSString</span> stringWithUTF8String: info.dli_sname];</div><div class="line">     <span class="keyword">if</span>([callerName isEqualToString: <span class="string">@"__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__"</span>])</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Do some notification stuff"</span>);</div><div class="line">     <span class="keyword">else</span></div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Do some regular stuff"</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这里是一些测试的代码：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">id obj = [[<span class="symbol">CallerInspection</span> alloc] init];</div><div class="line">  [[<span class="symbol">NSNotificationCenter</span> defaultCenter] addObserver: obj selector: @selector(method) name: @<span class="string">"notification"</span> object: obj];</div><div class="line">  [[<span class="symbol">NSNotificationCenter</span> defaultCenter] postNotificationName: @<span class="string">"notification"</span> object: obj];</div><div class="line">  [obj method];</div><div class="line"></div><div class="line">  <span class="symbol">LetsBreakCocoa</span>[<span class="number">47427</span>:<span class="number">303</span>] <span class="symbol">Do</span> some notification stuff</div><div class="line">  <span class="symbol">LetsBreakCocoa</span>[<span class="number">47427</span>:<span class="number">303</span>] <span class="symbol">Do</span> some regular stuff</div></pre></td></tr></table></figure></p>
<p>当然，这种方式不是很可靠，因为 <code>__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__</code>是 Apple 的内部符号，并且很有可能在未来修改。</p>
<h2 id="Dealloc-Swizzle"><a href="#Dealloc-Swizzle" class="headerlink" title="Dealloc Swizzle"></a>Dealloc Swizzle</h2><p>让我们使用 swizzle （方法调配技术）去调配<code>-[NSObject dealloc]</code>到一个不做任何事情的方法。在 ARC 下获得 @selector(dealloc) 有点棘手，因为我们不能直接读取它了：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Method</span> <span class="title">m</span> = <span class="title">class_getInstanceMethod</span><span class="params">([NSObject <span class="keyword">class</span>], sel_getUid("dealloc")</span>);</span></div><div class="line">method_setImplementation(m, imp_implementationWithBlock(^<span class="comment">&#123;&#125;</span>));</div></pre></td></tr></table></figure>
<p>现在我们坐下来欣赏这个例子所产生的混乱（简直就是代码界的黑暗料理）：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">for</span>(;;)</div><div class="line">    @<span class="keyword">autoreleasepool</span> &#123;</div><div class="line">        <span class="selector-attr">[[NSObject alloc]</span> <span class="selector-tag">init</span>];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>调配 dealloc 方法导致这个代码完美且合理地疯狂泄露，因为对象不能在任何地方被摧毁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用全新和有趣的方法搞崩 Cocoa 能够提供无尽的娱乐性。这也在真实的代码里体现出来了。想起我第一次遇到字符串中嵌入了 NUL ，那是充满痛苦的调试经历。其他只是为了好玩和适当的教学目的。</p>
<blockquote>
<p>That’s it for today! Come back next time for more fun and games.<br>Friday Q&amp;A is driven by reader suggestions, as always, so if you have<br>something you’d like to see discussed here, send it in!</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      在传统的文章中，我们一直致力于如何编写高效稳定的代码，努力提高代码的鲁棒性。然而在本文中，我们将会改变一下思维方式，采用破坏的方式去挖掘 Cocoa 的一些特性，虽然文中作者表现出一种“病态”的破坏心理，但正因为有这种精神，通过文中那些黑暗代码，可以让我们更加深刻地理解 Cocoa 。
    
    </summary>
    
      <category term="Objective-C" scheme="http://lin493369.github.io/categories/Objective-C/"/>
    
    
      <category term="mikeash" scheme="http://lin493369.github.io/tags/mikeash/"/>
    
      <category term="Cocoa" scheme="http://lin493369.github.io/tags/Cocoa/"/>
    
      <category term="crash" scheme="http://lin493369.github.io/tags/crash/"/>
    
      <category term="崩溃" scheme="http://lin493369.github.io/tags/%E5%B4%A9%E6%BA%83/"/>
    
  </entry>
  
  <entry>
    <title>【WatchOS 2教程系列四】WatchConnectivity：通过用户信息共享所有数据</title>
    <link href="http://lin493369.github.io/2015/11/09/WatchConnectivity--%E9%80%9A%E8%BF%87%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE/"/>
    <id>http://lin493369.github.io/2015/11/09/WatchConnectivity--通过用户信息共享所有数据/</id>
    <published>2015-11-08T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="http://natashatherobot.com/watchconnectivity-user-info/" target="_blank" rel="external">http://natashatherobot.com/watchconnectivity-user-info/</a><br>作者=Natasha The Robot<br>原文日期=2015/10/21</p>
<hr>
<p>在看这篇文章之前，确认你已经看过之前发布的几篇 WatchOS 2 的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World</a></li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">WatchConnectivity Introduction: Say Goodbye To The Spinner</a></li>
<li><a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">WatchConnectivity: Say Hello to WCSession</a></li>
</ul>
<p>通过 User Info 实现后台数据传输应该在你确保所有数据被传输的情况下（不仅仅像<a href="http://natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="external">Application Context</a>）。用户信息数据是在FIFO（先进先出）队列中排队传输的，所以不会有东西被重写。</p>
<p>一个典型的例子是在一个短信应用中使用它 —— 最后一条信息是确保能看到完整对话和上下文的重要部分。亦或者如果用户更新了他们文件信息的一小部分，则所有的修改应该被同步到 Watch 文件。</p>
<p>在这个教程中，我将会构建一个食物 emoji （表情符号）的社交应用，因为我是个吃货，并且我喜欢🍦！</p>
<p>另外，这个应用可以成为一个基于食品杂货店展示的 Apple Watch 应用 —— 你在手机上选择打算购买的食物 emoji ，然后跳转到应用上，这样你就好像在食品杂货店上浏览商品了！</p>
<p><img src="http://natashatherobot.com/wp-content/uploads/Screen-Shot-2015-10-21-at-5.16.42-AM.png" alt="这里写图片描述"></p>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>对于这个应用需要知道的是，我将会写很多抽象的数据更新层用于整个应用，因为 UI 中的多个地方需要有数据源更新，所以在示例应用中将会过度设计。</p>
<p>我同样尝试了不同的架构，尤其是 Swift 中的，所以如果你有任何有关于在Swift中更好地抽象数据层的建议反馈，请在评论中提出。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>在这个教程中，我假设你已经知道如何在 Xcode 创建一个简单的单视图应用，以及创建一个简单的食物 Emoji 列表的表视图。如果你遇到任何问题，可以参考这个 <a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo/blob/master/WCUserInfoDemo/FoodSelectionViewController.swift" target="_blank" rel="external">FoodSelectionViewController</a> 。</p>
<p>同样地，我也假设已经知道如何创建一个 Watch 应用并且在 Interface.storyboard 中做过基本的样式。如果你需要帮助，请查看<a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World tutorial</a> 和 <a href="http://natashatherobot.com/watchkit-create-table/" target="_blank" rel="external">WatchKit: Let’s Create a Table tutorial</a>.</p>
<p>最后，你需要会创建基础的用于管理 <code>WCSession</code> 的单例，以及在 <code>AppleDelegate</code> 中的<code>application:didFinishLaunchingWithOptions</code>和在Watch 扩展中<code>ExtensionDelegate</code> 的<code>applicationDidFinishLaunching</code>中启动它。如果不会的话，请查看 <a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">WatchConnectivity: Say Hello to WCSession tutorial</a>。</p>
<p>你的 iOS 应用看起来应该像这样：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your iOS app</span></div><div class="line"><span class="keyword">import</span> WatchConnectivity</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validSession: <span class="type">WCSession</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// paired - the user has to have their device paired to the watch</span></div><div class="line">        <span class="comment">// watchAppInstalled - the user must have your watch app installed</span></div><div class="line">        </div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> if the device is paired, but your watch app is not installed</span></div><div class="line">        <span class="comment">// consider prompting the user to install it for a better experience</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = session <span class="keyword">where</span> session.paired &amp;&amp; session.watchAppInstalled &#123;</div><div class="line">            <span class="keyword">return</span> session</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</div><div class="line">        session?.delegate = <span class="keyword">self</span></div><div class="line">        session?.activateSession()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 Watch 应用中应该有这样的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your WatchKit Extension</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> WatchConnectivity</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span> = <span class="type">WCSession</span>.defaultSession()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</div><div class="line">        session.delegate = <span class="keyword">self</span></div><div class="line">        session.activateSession()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果你需要额外的提示，你可以参考这个 <a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo" target="_blank" rel="external">教程的源码</a>。</p>
<p>现在让我们开始有趣的部分吧 🚀。</p>
<p>Sending Data</p>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>在应用中，每当用户选择一个食物项，都需要在后台传输给 Watch 应用。这意味着 iOS 应用是发送者。显然这是非常简单的。</p>
<p>只需扩展iOS应用的 WatchSessionManager 单例去传输用户数据：</p>
<p>Swift</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your iOS app</span></div><div class="line"></div><div class="line"><span class="comment">// MARK: User Info</span></div><div class="line"><span class="comment">// use when your app needs all the data</span></div><div class="line"><span class="comment">// FIFO queue</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Sender</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transferUserInfo</span><span class="params">(userInfo: [String : AnyObject])</span></span> -&gt; <span class="type">WCSessionUserInfoTransfer</span>? &#123;</div><div class="line">        <span class="keyword">return</span> validSession?.transferUserInfo(userInfo)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以现在，当用户选择一个食物的 cell ，你可以简单地调用以下的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FoodSelectionViewController.swift</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodSelectionViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> food = [<span class="string">"🍦"</span>, <span class="string">"🍮"</span>, <span class="string">"🍤"</span>,<span class="string">"🍉"</span>, <span class="string">"🍨"</span>, <span class="string">"🍏"</span>, <span class="string">"🍌"</span>, <span class="string">"🍰"</span>, <span class="string">"🍚"</span>, <span class="string">"🍓"</span>, <span class="string">"🍪"</span>, <span class="string">"🍕"</span>]</div><div class="line"></div><div class="line">    <span class="comment">// Table Data Source methods truncated</span></div><div class="line">    </div><div class="line">    <span class="comment">// MARK: Table view delegate</span></div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> foodItem = food[indexPath.row]</div><div class="line">        <span class="type">WatchSessionManager</span>.sharedManager.transferUserInfo([<span class="string">"foodItem"</span> : foodItem])</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就酱！已选择的食物项就在 FIFO 队列中了，并且将会发送给 Watch 应用 ！</p>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>现在 Watch 应用必须接收数据。这也是很简单的。只需要实现<code>WCSessionDelegate</code>中的<code>session:didReceiveUserInfo:</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your WatchKit Extension</span></div><div class="line"></div><div class="line"><span class="comment">// MARK: User Info</span></div><div class="line"><span class="comment">// use when your app needs all the data</span></div><div class="line"><span class="comment">// FIFO queue</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Receiver</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveUserInfo userInfo: [String : AnyObject])</span></span> &#123;</div><div class="line">        <span class="comment">// handle receiving user info</span></div><div class="line">        <span class="comment">// this will be filled in in the Updating Data section below</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>现在你接收到了数据，让我们开始最棘手的部分吧。尝试去更新你的 Watch 扩展的 <code>InterfaceController</code> 以及其他视图或者数据源。一个方式是通过 <code>NSNotificationCenter</code>，但是我将会尝试用不同的方法。这个部分可以用多种方法来做，并且对于应用来说有点过度设计，因此要记清楚这个。</p>
<p>既然我们用 Swift，我的目标是尽快地去改变值类型模型。不幸的是，正如我在 <code>WCSession</code> 中所提到的，<code>WCSessionDelegate</code>只能在一个<code>NSObject</code> 中实现。为了减轻这个，我创建了一个可以携带用户信息数据的 <code>DataSource</code> 值。因为用户信心是在一个 FIFO 队列顺序接收的，<code>DataSource</code> 应该持续追踪在队列中接收的数据。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">// in your WatchKit Extension</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DataSource</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> items: [<span class="type">Item</span>]</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Item</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Food</span>(<span class="type">String</span>)</div><div class="line">        <span class="keyword">case</span> <span class="type">Unknown</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">init</span>(items: [<span class="type">Item</span>] = [<span class="type">Item</span>]()) &#123;</div><div class="line">        <span class="keyword">self</span>.items = items</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">insertItemFromData</span><span class="params">(data: [String : AnyObject])</span></span> -&gt; <span class="type">DataSource</span> &#123;</div><div class="line">        <span class="keyword">let</span> updatedItems: [<span class="type">Item</span>]</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> foodItem = data[<span class="string">"foodItem"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">            updatedItems = [.<span class="type">Food</span>(foodItem)] + items</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            updatedItems = [.<span class="type">Unknown</span>] + items</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="type">DataSource</span>(items: updatedItems)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我可以现在设置一个 protocol ，通过更新的数据源更新所有需要知道数据改变的部分：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your WatchKit Extension</span></div><div class="line"><span class="comment">//  WatchSessionManager.swift</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DataSourceChangedDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataSourceDidUpdate</span><span class="params">(dataSource: DataSource)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在让我们进入有趣的部分！你的<code>WatchSessionManager</code>将需要以某种方式去追踪所有的<code>dataSourceChangedDelegates</code>。这可以通过一个数组以及一个可以添加和删除数组中的delegate方法来实现。<code>WatchSessionManager</code>还需要持续追踪最近的<code>DataSource</code>拷贝，这样就可以使用<code>DataSource</code>中的数据去创建一个带有最新数据的新 <code>DataSource</code>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your WatchKit Extension</span></div><div class="line">   <span class="comment">//  WatchSessionManager.swift</span></div><div class="line">   </div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">   <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</div><div class="line">   <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">       <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span> = <span class="type">WCSession</span>.defaultSession()</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> <span class="keyword">var</span> dataSource = <span class="type">DataSource</span>()</div><div class="line">   <span class="keyword">private</span> <span class="keyword">var</span> dataSourceChangedDelegates = [<span class="type">DataSourceChangedDelegate</span>]()</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</div><div class="line">       session.delegate = <span class="keyword">self</span></div><div class="line">       session.activateSession()</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">addDataSourceChangedDelegate</span><span class="params">(delegate: T)</span></span> &#123;</div><div class="line">       dataSourceChangedDelegates.append(delegate)</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">removeDataSourceChangedDelegate</span><span class="params">(delegate: T)</span></span> &#123;</div><div class="line">       <span class="keyword">for</span> (index, dataSourceDelegate) <span class="keyword">in</span> dataSourceChangedDelegates.<span class="built_in">enumerate</span>() &#123;</div><div class="line">           <span class="keyword">if</span> <span class="keyword">let</span> dataSourceDelegate = dataSourceDelegate <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">where</span> dataSourceDelegate == delegate &#123;</div><div class="line">               dataSourceChangedDelegates.removeAtIndex(index)</div><div class="line">               <span class="keyword">break</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>当用户信息接收到后我们可以添加实现了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in your WatchKit Extension</span></div><div class="line">    <span class="comment">//  WatchSessionManager.swift</span></div><div class="line">    <span class="comment">// MARK: User Info</span></div><div class="line">    <span class="comment">// use when your app needs all the data</span></div><div class="line">    <span class="comment">// FIFO queue</span></div><div class="line">    <span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</div><div class="line">    <span class="comment">// Receiver</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveUserInfo userInfo: [String : AnyObject])</span></span> &#123;</div><div class="line">        <span class="comment">// handle receiving user info</span></div><div class="line">        dispatch_async(dispatch_get_main_queue()) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> dataSource = <span class="keyword">self</span>?.dataSource.insertItemFromData(userInfo) &#123;</div><div class="line">                <span class="keyword">self</span>?.dataSource = dataSource</div><div class="line">                <span class="keyword">self</span>?.dataSourceChangedDelegates.forEach &#123;</div><div class="line">                    $<span class="number">0</span>.dataSourceDidUpdate(dataSource)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line">```  </div><div class="line">现在我们只需要确保我们的`<span class="type">InterfaceController</span>`继承了`<span class="type">DataSourceChangedDelegate</span>`，并且被`<span class="type">WatchSessionManager</span>`持续追踪着：</div></pre></td></tr></table></figure>
<pre><code>// in your WatchKit Extension
//  InterfaceController.swift
class InterfaceController: WKInterfaceController, DataSourceChangedDelegate {
@IBOutlet var foodTable: WKInterfaceTable!

override func awakeWithContext(context: AnyObject?) {
    super.awakeWithContext(context)

    WatchSessionManager.sharedManager.addDataSourceChangedDelegate(self)
    loadTableData(DataSource())
}

override func didDeactivate() {

    // remove InterfaceController as a dataSourceChangedDelegate
    // to prevent memory leaks
    WatchSessionManager.sharedManager.removeDataSourceChangedDelegate(self)
    super.didDeactivate()
}

// MARK: DataSourceUpdatedDelegate
// update the table once the data is changed!
func dataSourceDidUpdate(dataSource: DataSource) {
    loadTableData(dataSource)
}
}
private extension InterfaceController {

private func loadTableData(dataSource: DataSource) {

    foodTable.setNumberOfRows(dataSource.items.count, withRowType: &quot;FoodTableRowController&quot;)

    for (index, item) in dataSource.items.enumerate() {
        if let row = foodTable.rowControllerAtIndex(index) as? FoodTableRowController {
            switch item {
            case .Food(let foodItem):
                row.foodLabel.setText(foodItem)
            case .Unknown:
                row.foodLabel.setText(&quot;¯\\_(ツ)_/¯&quot;)
            }

        }
    }

}
</code></pre><p>}<br>```<br>就是这样啦！</p>
]]></content>
    
    <summary type="html">
    
      通过 User Info 实现后台数据传输应该在你确保所有数据被传输的情况下（不仅仅像 Application Context）。用户信息数据是在FIFO（先进先出）队列中排队传输的，所以不会有东西被重写。
    
    </summary>
    
      <category term="WatchOS 入门" scheme="http://lin493369.github.io/categories/WatchOS-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Natasha The Robot" scheme="http://lin493369.github.io/tags/Natasha-The-Robot/"/>
    
  </entry>
  
  <entry>
    <title>减少在Facebook iOS应用中的FOOMs</title>
    <link href="http://lin493369.github.io/2015/11/04/%E5%87%8F%E5%B0%91%E5%9C%A8FacebookiOS%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84FOOMs%EF%BC%88%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%89%8D%E5%8F%B0%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%EF%BC%89/"/>
    <id>http://lin493369.github.io/2015/11/04/减少在FacebookiOS应用中的FOOMs（运行在前台的内存不足）/</id>
    <published>2015-11-03T16:00:00.000Z</published>
    <updated>2017-04-13T03:31:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接 = <a href="https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/" target="_blank" rel="external">https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/</a><br>作者 =     <a href="https://code.facebook.com/posts/1146930688654547/reducing-fooms-in-the-facebook-ios-app/#" target="_blank" rel="external">Ali Ansari</a>      <a href="https://www.facebook.com/gpstrucha" target="_blank" rel="external">Grzegorz Pstrucha</a><br>原文日期 = 2015-08-24</p>
<hr>
<p>译者：本文是 Facebook 应用的开发工程师在发现应用运行中屡禁不死的崩溃问题，通过逐步地调查和研究崩溃发生的时间点，提出了自有的解决方案，虽然文中并没有很详细的解决方案，但是对于如何排查和解决问题的方式以及对应用性能严谨的态度，是很值得我们借鉴的。</p>
<hr>
<p>在 Facebook，我们一直致力于让应用稳定、快速、可靠。在 Facebook 的 iOS 应用上，我们已经做了很多工作去减少应用的崩溃率以及全面提高应用的稳定性。此前，大多数的崩溃都是由于常规性错误，一般都会伴随着相应代码行的栈回溯信息，并且提供了可能导致问题所在的提示信息。</p>
<p>当我们继续解决崩溃问题时，我们观察到需要解决的崩溃比例正在下降，但是我们注意到 App Store 指出社区继续出现令人失望的应用崩溃。我们深入研究了用户报告，并且从理论上说明内存不足（out-of-memory events (OOMs)）可能正在发生。OOMs 一般发生在系统运行在低内存的环境下，OS 为了回收内存而终止应用。它既可能发生在前台，也可以是后台。我们在内部称之为 FOOMs 和 BOOMs — 当我们说应用爆炸（BOOM）了，好像很好玩的样子。</p>
<p>从用户的角度来看，一个前台内存不足导致的崩溃和常规的崩溃是不好分辨的。一般分为几种情况，应用异常终止，似乎消失，以及用户返回设备主屏幕。如果内存的消耗速度急速增长，那么应用会在不接到任何通知的情况下被终止掉。在 iOS 中，OS 会将内存警告发给应用，但是不能保证 OS 一定会在终止应用之前给应用发送警告信息。这就导致我们无法轻易地知道应用是否是由于内存压力而被 OS 终止。</p>
<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>为了掌握应用由于 OOM 崩溃而终止的频率，我们从所有已知的途径列举应用可能终止的情况并记录他们。这样问题就转变为”导致应用重启的是什么？”</p>
<p>应用需要重启的原因如下：</p>
<ol>
<li>应用已经更新</li>
<li>应用退出或终止</li>
<li>应用崩溃</li>
<li>用户强制退出应用</li>
<li>设备重启（包括 OS 升级）</li>
<li>应用在前台或者后台内存不足（OOM）</li>
</ol>
<p>通过排除处理，寻找区别于其他重启原因的实例，借此我们可以找出 OOM 发生的时间。此外，我们还追踪应用进入后台和前台的时间，借此我们可以精确地把 OOMs 分为 BOOMs 和 FOOMs。</p>
<p><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-xft1/t39.2365-6/11891371_510065462479783_784800705_n.jpg" alt="这里写图片描述"></p>
<p>日志显示在设备处于低内存状态下，有很高的比率发生 OOMs 。当应用进程在受内存限制的设备上像驱逐一样被终止，真的非常令人沮丧。查看相关的日志记录帮助我们验证排除法的效果，并且能继续提高日志记录（我们无法准确验证所有的事例，例如应用升级）。</p>
<p>我们最初在减少 OOMs 所做的努力，是试图在应用不再需要内存时，就尽可能快地主动缩小应用的内存占用。不幸的是，我们没有发现 OOM 崩溃的数量没有有切实的改变，所以我们把关注点转移到大的内存分配上，开始观察那些可能被泄露的内存（没有清理干净的），尤其是潜在的循环引用。</p>
<h2 id="内存使用分析"><a href="#内存使用分析" class="headerlink" title="内存使用分析"></a>内存使用分析</h2><p>当我们开始解决内存泄露问题时，我们看到 OOM 崩溃率有所降低，但是依然没有达到我们预期。紧接着，我们深入研究 Apple 的 Instruments 应用的 memory profiler，并且注意到只要应用打开任何 web 网页，一个重复样式的 <code>UIWebView</code> 就会分配大量的内存。我们还发现内存经常没有回收，即使在用户离开了网页并且 web 视图被关闭的情况下。</p>
<p>我们试图做过大量的优化，例如清理缓存和内容，但是应用进程的内存占用在跳转向 web 视图时总是显著增长。iOS包含一个新的类 — <code>WKWebView</code> — 它把大多数的工作都放在了分开的进程里，这意味着大多数跟内存相关的 web 视图使用将不会分配给我们的进程。在低内存的事件中，web 视图的进程将会被终止，但是我们的应用有很大可能会继续存活下去。在我们把应用迁移为 <code>WKWebView</code> 后，我们确切地看到 OOMs 发生的比率有了显著的降低。Yay！</p>
<p><img src="https://fbcdn-dragon-a.akamaihd.net/hphotos-ak-xfp1/t39.2365-6/11891352_794615773990111_422386740_n.jpg" alt="这里写图片描述"></p>
<h2 id="内存分配比率"><a href="#内存分配比率" class="headerlink" title="内存分配比率"></a>内存分配比率</h2><p>当通过 Instruments 分析内存使用时，我们还发现应用中分配了大量的临时内存（~30 MB），然后马上释放掉。如果 CPU 在这个分配过程中是空闲的，那么 OS 会终止程序。我们要禁止此类临时分配，这可以帮助我们在 30% 确定场景中减少 OOM 崩溃，我们还实验并发现，相较于重复分配和释放内存，分配一次然后管理内存对于应用的可靠性是更好的。</p>
<h2 id="阻止内存恶化"><a href="#阻止内存恶化" class="headerlink" title="阻止内存恶化"></a>阻止内存恶化</h2><p>即使用了 <code>WKWebView</code>，我们仍然发现一点点内存泄露都能够显著地导致影响 OOM 的发生比率。在我们通常的发布计划和贡献给应用的许多的团队中，在发布的应用中捕获和阻止内存泄露是非常重要的。我们改变了扫描设备，独创性地设计了用于测试移动性能，为了记录大量进程中的常驻内存，允许扫描设备去标记恶化情况，只要它们被添加了。这已经帮助我们把 OOM 发生比率保持在比最初解决问题时低得多的水平上。</p>
<h2 id="应用内部的内存分析器"><a href="#应用内部的内存分析器" class="headerlink" title="应用内部的内存分析器"></a>应用内部的内存分析器</h2><p>上一个在这个项目中我们使用的关键技术是去构造一个应用内部的内存分析器，通过追踪所有的 Objective-C 对象的内存分配进而快速分析应用。我们把这个配置在扫描仪上，然后在里面建立我们的应用。</p>
<p>它是如何工作的：对于系统中的每一个类，维护一个当前活动的实例的数量。我们可以在任何点要求它打印出每一个类对象的现存数目。然后我们就可以分析这些数据任何异常的 release-to-release 用以辨认我们应用中总体上的内存分配模式，如果计数急剧变化，这一般可以验证为内存泄露。我们准备去用一种性能足够用并且不会产生对用户有影响的方法去实现。</p>
<p>下面简要说明我们的策略以及我们是如何追踪 NSObject 的内存分配。</p>
<p>我们一开始创建一个内存分配追踪类。这是个超级直接和简单的类，有统计实例数量的公共方法用于统计实例数量的增加和减少。我们使用 C++ 而不是Objective-C，是由于那样可以最小化追踪器的内存分配和 CPU 占有率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AllocationTracker &#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> AllocationTracker* <span class="title">tracker</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">incrementInstanceCountForClass</span><span class="params">(Class aCls)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrementInstanceCountForClass</span><span class="params">(Class aCls)</span></span>;</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;Class, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; countsSnapshot();</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以使用 iOS 的方法调配技术（称为“swizzling”，使用runtime 的<code>class_replaceMethod</code>方法），用-<code>fb_originalAlloc</code> 和 <code>-fb_originalDealloc</code>方法去替换标准的iOS方法 <code>+alloc</code> 和<code>+dealloc</code>。</p>
<p>然后我们用新实现的增加和减少的分配和释放实例数量的方法相应地替代<code>+alloc</code> 和 <code>+dealloc</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@implementation</span> NSObject (AllocationTracker)</div><div class="line"></div><div class="line">+ (id)fb_newAlloc</div><div class="line">&#123;</div><div class="line">  id <span class="keyword">object</span> = [self fb_originalAlloc];</div><div class="line">  AllocationTracker::tracker()-&gt;incrementInstanceCountForClass([<span class="keyword">object</span> <span class="class"><span class="keyword">class</span>]);</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">object</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fb_newDealloc</div><div class="line">&#123;</div><div class="line">  AllocationTracker::tracker()-&gt;decrementInstanceCountForClass([<span class="keyword">object</span> <span class="class"><span class="keyword">class</span>]);</span></div><div class="line">  [self fb_originalDealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@end</span></div></pre></td></tr></table></figure>
<p>然后，当应用运行时，我们可以调用快照方法有规律地打印当前存活实例的数量。</p>
<h2 id="应用可靠性"><a href="#应用可靠性" class="headerlink" title="应用可靠性"></a>应用可靠性</h2><p>一旦我们在 Facebook 的 iOS 应用中实施更改去解决内存问题，我们会看到 (F)OOMs 和用户的应用崩溃报告有显著的降低。OOM 崩溃对于我们来说是盲点，因为没有正式的体系或者 API 可以随意检测到它们。没有人喜欢一个应用突然关闭。但是使用某些工具，或者最新的 iOS 技术，以及一些灵巧的方法去解决这个问题，能够让我们的应用更加可靠，并且保证你不会在打开 web 视图查看一篇有趣的文章（就像你在看的这篇文章）时突然关闭。</p>
<blockquote>
<p>Additional thanks to Linji Yang, Anoop Chaurasiya, Flynn Heiss,<br>Parthiv Patel, Justin Pasqualini, Cloud Xu, Gautham Badrinathan, Ari<br>Grant, and many others for helping reduce the FOOM rate.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      在 Facebook，我们一直致力于让应用稳定、快速、可靠。在 Facebook 的 iOS 应用上，我们已经做了很多工作去减少应用的崩溃率以及全面提高应用的稳定性。此前，大多数的崩溃都是由于常规性错误，一般都会伴随着相应代码行的栈回溯信息，并且提供了可能导致问题所在的提示信息。
    
    </summary>
    
      <category term="性能优化" scheme="http://lin493369.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Facebook" scheme="http://lin493369.github.io/tags/Facebook/"/>
    
      <category term="内存不足" scheme="http://lin493369.github.io/tags/%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/"/>
    
      <category term="FOOMs" scheme="http://lin493369.github.io/tags/FOOMs/"/>
    
  </entry>
  
  <entry>
    <title>【WatchOS 2教程系列三】WatchConnectivity学习之WCSession</title>
    <link href="http://lin493369.github.io/2015/10/25/WatchConnectivity-%E5%AD%A6%E4%B9%A0%E4%B9%8BWCSession(1)/"/>
    <id>http://lin493369.github.io/2015/10/25/WatchConnectivity-学习之WCSession(1)/</id>
    <published>2015-10-24T16:00:00.000Z</published>
    <updated>2017-04-13T03:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接 = <a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/</a><br>作者 = Natasha The Robot<br>原文日期 = 2015-09-21</p>
<hr>
<p>在读这篇文章之前，请检查一下你是否已经学习了之前两篇关于<code>WatchOS 2</code>的文章：</p>
<p><a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World</a><br><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">WatchConnectivity Introduction: Say Goodbye To The Spinner</a></p>
<p><code>WCSession</code>就是<code>WatchConnectivity</code>的魔法。所以让我们赶紧深挖它吧！</p>
<p><code>WCSession.defaultSession()</code>会返回<code>WCSession</code>的单例，用于<code>iOS</code>和<code>Watch app</code>之间的数据传输。但是，在使用<code>WCSession</code>时仍有一些值得注意的地方。</p>
<p>首先，你必须设置一个<code>session</code>的<code>delegate</code>并启动它。</p>
<blockquote>
<p>默认的<code>session</code>用于两个相应app的通信（例如<code>iOS app</code>和它的原生WatchKit的扩展）。这个<code>session</code>提供发送、接收、追踪状态的方法。</p>
<p>启动一个<code>app</code>时，应该在默认的<code>session</code>上设置一个<code>delegate</code>并启动它。这将允许系统填充状态属性和提供任何优秀的背景传输。—— <code>Apple</code> 文档说明。</p>
</blockquote>
<p>所以你的代码应该写成这样：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="attr">session</span> = WCSession.defaultSession()</div><div class="line">session.<span class="attr">delegate</span> = self</div><div class="line">session.activateSession()</div></pre></td></tr></table></figure>
<p>在这里，我推荐将你的<code>WCSession</code>作为一个单例，这样你就可以在<code>app</code>中随意使用它：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> WatchConnectivity</div><div class="line"></div><div class="line"><span class="comment">// Note that the WCSessionDelegate must be an NSObject </span></div><div class="line"><span class="comment">// So no, you cannot use the nice Swift struct here!</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Instantiate the Singleton</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</div><div class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Keep a reference for the session, </span></div><div class="line">    <span class="comment">// which will be used later for sending / receiving data</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</div><div class="line">    </div><div class="line">    <span class="comment">// Activate Session</span></div><div class="line">    <span class="comment">// This needs to be called to activate the session before first use!</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</div><div class="line">        session.delegate = <span class="keyword">self</span></div><div class="line">        session.activateSession()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以你可以在<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法中启动你的<code>session</code>，并且可以在<code>app</code>的任意地方使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@UIApplicationMain</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// truncated...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication,</span></span></div><div class="line">        didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; <span class="type">Bool</span></div><div class="line">    &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// Set up and activate your session early here!</span></div><div class="line">        <span class="type">WatchSessionManager</span>.sharedManager.startSession()</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// truncated...</span></div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是启动<code>session</code>是远远不够的。你需要通过<code>WCSession</code>的多重检查机制，使得你的应用不需要做格式化传输数据的额外工作。</p>
<h2 id="检查设备支持"><a href="#检查设备支持" class="headerlink" title="检查设备支持"></a>检查设备支持</h2><blockquote>
<p>检查iOS设备是否支持session，WatchOS都是支持session的。</p>
</blockquote>
<p>如果你有一个普遍适用的<code>app</code>，例如，<code>iPad</code>将不会支持<code>WCSession</code>（因为<code>iPad</code>不能和<code>Watch</code>配对）。因此需要确保在<code>iOS</code>项目中做<code>isSupported()</code>检查：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> WCSession.isSupported() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="attr">session</span> = WCSession.defaultSession()</div><div class="line">    session.<span class="attr">delegate</span> = self</div><div class="line">    session.activateSession()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这意味着你的<code>WatchSessionManager</code>单例需要适应不支持<code>WCSession</code>的场景（使用选项）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Modification to the WatchSessionManager in the iOS app only</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// truncated ... see above section</span></div><div class="line">    </div><div class="line">    <span class="comment">// the session is now an optional, since it might not be supported</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></div><div class="line">    </div><div class="line">    <span class="comment">// starting a session has to now deal with it being an optional</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</div><div class="line">        session?.delegate = <span class="keyword">self</span></div><div class="line">        session?.activateSession()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="用于-Watch-的-iOS-App-状态"><a href="#用于-Watch-的-iOS-App-状态" class="headerlink" title="用于 Watch 的 iOS App 状态"></a>用于 Watch 的 iOS App 状态</h2><p>如果你从<code>iOS app</code>发送数据到<code>Watch</code>，你需要做一些额外的检查，这样当<code>Watch</code>处于无法接受数据的状态时，你就不会浪费<code>CPU</code>资源去处理用于传输的数据。</p>
<p><strong>配对</strong></p>
<p>显然，为了从<code>iOS</code>设备传输数据到<code>Watch</code>，用户必须有一个<code>Watch</code>并且和<code>iOS</code>设备配对。</p>
<p><strong>安装 Watch app</strong></p>
<p>一个用户可能有一对设备，但是他们可能删除了设备上的<code>Watch App</code>，所以为了数据传输，你需要检查你的应用确实有安装在所配对的<code>Apple Watch</code>上面。</p>
<p>如果用户有一对设备，但是未安装你的<code>app</code>，那么如果用户能够从你的<code>watch app版本</code>中获得好处，那将成为做这个检查和提示用户安装<code>watch app</code>的关键点。</p>
<p>当单例中的<code>session</code>保持工作时，为了让这些检查更加简单，并且能够在应用中随意使用，我喜欢在<code>iOS app</code>中创建一个<code>validSession</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Modification to the WatchSessionManager in the iOS app only</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// truncated... see above</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></div><div class="line">    </div><div class="line">    <span class="comment">// Add a validSession variable to check that the Watch is paired</span></div><div class="line">    <span class="comment">// and the Watch App installed to prevent extra computation </span></div><div class="line">    <span class="comment">// if these conditions are not met.</span></div><div class="line">     </div><div class="line">    <span class="comment">// This is a computed property, since the user can pair their device and / or</span></div><div class="line">    <span class="comment">// install your app while using your iOS app, so this can become valid  </span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validSession: <span class="type">WCSession</span>? &#123;</div><div class="line">       </div><div class="line">        <span class="comment">// paired - the user has to have their device paired to the watch</span></div><div class="line">        <span class="comment">// watchAppInstalled - the user must have your watch app installed</span></div><div class="line">        </div><div class="line">        <span class="comment">// <span class="doctag">Note:</span> if the device is paired, but your watch app is not installed</span></div><div class="line">        <span class="comment">// consider prompting the user to install it for a better experience</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = session <span class="keyword">where</span> session.paired &amp;&amp; session.watchAppInstalled &#123;</div><div class="line">            <span class="keyword">return</span> session</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// truncated... see above</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>判断并发是否可用</strong></p>
<p>最后，如果你在<code>app</code>中有使用并发，你必须检查并发是否可用。我不会在<code>WatchConnectivity</code>教程中说明过多并发的细节，但是如果你想要知道更多，可以观看超级有用和全面的 <a href="https://developer.apple.com/videos/wwdc/2015/?id=209" target="_blank" rel="external">WWDC 2015 Creating Complications with ClockKit session</a>。</p>
<p><strong>sessionWatchStateDidChange</strong></p>
<p>为了以防你的<code>iOS app</code>需要<code>WCSession</code>状态变化的信息，这里有一个delegate方法，专门用于通知<code>WCSession</code>的状态变化：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/** Called when <span class="literal">any</span> of the Watch <span class="keyword">state</span> properties change */</div><div class="line">    func sessionWatchStateDidChange(session: WCSession) &#123;</div><div class="line">        // handle <span class="keyword">state</span> change here</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>例如，如果你的<code>app</code>需要安装<code>Watch App</code>，你可以实现这个<code>delegate</code>方法，然后去检测你的<code>Watch App</code>是否真正安装了，并且让用户根据<code>iOS app</code>中的添加流顺序去完成最终的安装。</p>
<h2 id="检查设备可达状态"><a href="#检查设备可达状态" class="headerlink" title="检查设备可达状态"></a>检查设备可达状态</h2><p>为了正确在<code>iOS</code>和<code>Watch</code>使用<code>Interactive Messaging</code>传输数据，你需要做一些额外的工作以确保两个<code>app</code>处于可达状态：</p>
<p><code>Watch app</code>上的可达能力需要所配对的<code>iOS</code>设备在重启后至少已经解锁一次了。这个属性能够用于决定<code>iOS</code>设备是否需要被解锁。如果<code>reachable</code>设为<code>NO</code>，可能是由于设备重启过，需要解锁。如果处于这种状态，<code>Watch</code>将会展示一个提示框建议用户去解锁他们配对的<code>iOS</code>设备。</p>
<p>在使用<code>Interactive Messaging</code>时，我喜欢增加一个额外的<code>valideReachableSession</code>变量到我的单例中：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// MARK: Interactive Messaging</div><div class="line">extension WatchSessionManager &#123;</div><div class="line">    </div><div class="line">    // Live messaging! App has to be reachable</div><div class="line">   <span class="keyword"> private</span> var validReachableSession: WCSession? &#123;</div><div class="line">        //<span class="built_in"> check </span>for validSession on iOS only (see above)</div><div class="line">        // in your Watch App, you can just do an<span class="built_in"> if </span>session.reachable<span class="built_in"> check</span></div><div class="line">       <span class="built_in"> if </span>let session = validSession where session.reachable &#123;</div><div class="line">           <span class="built_in"> return </span>session</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> return </span>nil</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果<code>session</code>是不可达的，你可以如<code>Apple</code>所建议的那样，提示用户去解锁他们的iOS设备。为了知道用户解锁了他们的设备，实现<code>sessionReachabilityDidChange</code>的<code>delegate</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionReachabilityDidChange</span><span class="params">(session: WCSession)</span></span> &#123;</div><div class="line">    <span class="comment">// handle session reachability change</span></div><div class="line">    <span class="keyword">if</span> session.reachable &#123;</div><div class="line">        <span class="comment">// great! continue on with Interactive Messaging</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 😥 prompt the user to unlock their iOS device</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上！现在你应该已经知道了<code>WCSession</code>的一些要领，所以我们将会学习更加好玩的部分 —— 真正使用它在<code>iOS</code>和<code>Watch</code>之间接收和发送收据！</p>
<p>你可以在<code>Github</code>查看完整的<a href="https://gist.github.com/NatashaTheRobot/6bcbe79afd7e9572edf6" target="_blank" rel="external">WatchSessionManager单例</a>。</p>
]]></content>
    
    <summary type="html">
    
      WCSession 就是 WatchConnectivity 的魔法。所以让我们赶紧深挖它吧！
    
    </summary>
    
      <category term="WatchOS 入门" scheme="http://lin493369.github.io/categories/WatchOS-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="WatchConnectivity" scheme="http://lin493369.github.io/tags/WatchConnectivity/"/>
    
  </entry>
  
  <entry>
    <title>Storyboard Reference, Strong IBOutlet, Scene Dock in iOS 9</title>
    <link href="http://lin493369.github.io/2015/10/20/StoryboardReference,StrongIBOutlet,SceneDockiOS9/"/>
    <id>http://lin493369.github.io/2015/10/20/StoryboardReference,StrongIBOutlet,SceneDockiOS9/</id>
    <published>2015-10-19T16:00:00.000Z</published>
    <updated>2017-04-11T11:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接=<a href="https://www.invasivecode.com/weblog/storyboard-strong-iboutlet-scene-dock/" target="_blank" rel="external">https://www.invasivecode.com/weblog/storyboard-strong-iboutlet-scene-dock/</a><br>作者=<a href="http://twitter.com/geppyp" target="_blank" rel="external">Geppy</a><br>原文日期=2015-10-11</p>
<hr>
<p>在这个教程中，我想要展示一些有关于<code>Xcode 7</code>中<code>Interface Builder</code>的新特性，我相信这将会改变你对<code>Storyboards</code>的看法。</p>
<h2 id="Strong-引用的-IBOutlet"><a href="#Strong-引用的-IBOutlet" class="headerlink" title="Strong 引用的 IBOutlet"></a>Strong 引用的 IBOutlet</h2><p><code>Apple</code>已经对<code>Xib</code>和<code>Storyboard</code>文件做了很多优化。并且由于这些优化，你现在可以将<code>IBOutlet</code>定义为<code>strong</code>，替代原来的<code>weak</code>。<code>Apple</code>曾在上一届的<code>WWDC</code>上指出这一点，因此让我们来看一下其中的更多细节。你可以从这个<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html" target="_blank" rel="external">文档</a>中找到管理Nib文件中对象生命周期的章节：</p>
<blockquote>
<p><code>Outlet</code>一般来说应该为<code>weak</code>，除了在<code>nib</code>文件 ( 或者<code>iOS</code>,  <code>storyboard scene</code>) 中的File’s<br>Owner的顶级对象，这个对象可以是<code>strong</code>。你创建的<code>Outlets</code>应该为<code>weak</code>，原因如下：</p>
<ul>
<li>你创建的一个<code>view controller</code>视图的子视图或者<code>window controller</code>窗体视图的<code>Outlets</code>，是对象之间的弱引用，不应该有依赖关系。</li>
<li><code>strong</code>的<code>outlet</code>通常是特殊的<code>framework</code>类（如：<code>UIViewController</code>视图的<code>outlet</code>，或者<code>NSWindowController</code>视窗的<code>outlet</code>）。</li>
</ul>
</blockquote>
<p>正如这个段落所解释的一样，<code>view controller</code>视图的子视图 <code>outlet</code>应该为<code>weak</code>，因为这个视图已经被<code>nib</code>文件的顶级对象所拥有了。然而，当一个<code>Outlet</code>被定义为<code>weak</code>指针时，<code>ARC</code>会在编译期间调用以下函数：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">id</span> objc_storeWeak(<span class="built_in">id</span> *object, <span class="built_in">id</span> value);</div></pre></td></tr></table></figure>
<p>这个函数把对象的值作为<code>key</code>，并把它添加到<code>table</code>中。这个<code>table</code>被称为<code>weak table</code>。<code>ARC</code>使用这个<code>table</code>去存储应用中的所有的<code>weak</code>指针。现在，当对象被<code>deallocated</code>时，<code>ARC</code>将会指向<code>weak table</code>并且将<code>weak</code>引用置为<code>nil</code>。同时，<code>ARC</code>将会调用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_destroyWeak</span>(<span class="params">id * <span class="keyword">object</span></span>)</span>;</div></pre></td></tr></table></figure>
<p>紧接着，注销这个对象并再次调用<code>objc_destroyWeak</code>：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_storeWeak(id *<span class="keyword">object</span>, <span class="keyword">nil</span>);</div></pre></td></tr></table></figure>
<p>这种<code>weak</code>引用关联的生命周期是<code>strong</code>引用的2-3倍。所以，通过避免简单地定义<code>outlets</code>为<code>strong</code>，使用弱引用是一种运行期间的通用做法。</p>
<p>我想这个决策与已废弃的<code>viewDidUnload</code>方法有关。知道<code>iOS 5</code>，这个方法被用于清空在低内存环境下的视图。正如文档中解释的那样：</p>
<blockquote>
<p>在iOS 5之前，当发生低内存警告或者当前view<br>controller的视图不被需要时，在视图被释放之后，系统会选择性地调用这个方法。这个方法让你可以进行最后的清理工作。如果你的视图存储了视图或者其子视图的单独引用，你应该使用这个方法去释放这些引用。</p>
</blockquote>
<p>在那时，定义一个属性为<code>weak</code>是有意义的，因为这就不用在<code>viewDidUnload</code>额外地释放对象。但是在<code>iOS 9</code>中，我相信我们已经有足够的时间去避免使用这个方法。因此，在<code>IBOutlets</code>定义<code>weak</code>是没意义的。</p>
<h2 id="现在-Storyboard-的限制"><a href="#现在-Storyboard-的限制" class="headerlink" title="现在 Storyboard 的限制"></a>现在 Storyboard 的限制</h2><p><code>Apple</code>是在<code>iOS 5</code>中开始提出<code>storyboards</code>的。在此之前，使用<code>Interface Builder</code>的<code>nib</code>文件是创建UI的唯一途径。在<code>iOS</code>开发中，单个文件中操纵多个<code>nib</code>文件是很普遍的。然而，为了理解应用流以及<code>view controller</code>如何连接在一起，开发者需要去每一个<code>view controller</code>类内去找出跳转到下一个界面的桥接点。这是一个非常耗费时间的工序，尤其当你不是应用的原始开发者时。</p>
<p><code>Apple</code>提出<code>Storyboards</code>用以简化这个过程，并帮助开发者能够对整个应用程序流有完全的控制。除此之外，<code>storyboards</code>允许你在一个文件中拥有一个<code>view controller</code>视图（通过添加 <code>.storyboard</code>文件）。用这种方式，你可以看到整个程序的流状态，并且能够方便地理解<code>view controller</code>的连接关系。然而，<code>storyboards</code>也引出了一些问题。把所有的<code>nib</code>文件都放在一个文件中显然是非常便利并且能完美工作，但是这只是在你为单人开发的前提下。只要你的团队扩大了，你会使用版本控制，例如<code>git</code>或者<code>subversion</code>，这时你就会讨厌<code>storyboards</code>。因为，当把修改合并到一个通用的<code>git branch</code>时，就会产生冲突，而解决此类冲突是很头疼的。在编译期间，<code>nib</code>会被编译成<code>XML</code>文件。所以，为了解决合并冲突，你需要比较两个巨大的<code>XML</code>文件，并且要尝试理清哪部分是你修改的，哪部分是你同事修改的。此外，<code>Apple</code>经常修改这个文件格式。所以，试图去理解并且反转<code>storyboard</code>格式是非常浪费时间的。</p>
<p>例如，在<code>iNVASIVECODE</code>（这是作者所在的公司），我们倾向于使只用<code>storyboards</code>去构建<code>app</code>原型。我们的设计师能够在几个小时内设计出一个能够在<code>iOS</code>设备上运行的原型，有时候只需要几分钟。这样可以在不写一行代码的情况下使用<code>storyboards</code>。所以，<code>storyboards</code>对于构建原型来说是非常方便的，但是不建议在开发期间使用。</p>
<p>另一个<code>storyboard</code>的重要局限是不能添加不属于一个场景体系的视图。我个人认为跟前面所说的合并问题相比，这是一个更为致命的限制。只要能够使用，我必定会使用<code>IB</code>。我喜欢这个，因为这可以避免写代码。但是使用<code>storyboards</code>，不能添加场景体系以外的视图。因此，当我需要额外的视图时，我就强迫自己去使用<code>nib</code>。</p>
<p><code>Storyboards</code>还有一个额外的局限就是过渡问题。在<code>iOS 7</code>以及之后的<code>iOS 8</code>，<code>Apple</code>提出了在两个<code>view controller</code>之间创建一个定制过渡的新方法。当你运行一个<code>segue</code>时，这个新方法需要创建不能使用<code>storyboard</code>的特殊对象。所以，如果你想要添加定制的过渡方法到你的<code>view controllers</code>，你要避免使用<code>storyboards</code>。</p>
<p>但是猜猜看！<code>Xcode 7</code>和<code>iOS 9</code>为我们解决了所有的这些问题。</p>
<h2 id="Storyboard-Reference"><a href="#Storyboard-Reference" class="headerlink" title="Storyboard Reference"></a>Storyboard Reference</h2><p>在<code>Xcode 7</code>中，我们有一个在多个<code>storyboards</code>中组织<code>scenes</code>的新方法，并且能对它们进行引用。让我们来看一个实践的例子。下载这个我已经准备好的<a href="http://www.invasivecode.com/documents/Multiboard.zip" target="_blank" rel="external">例子</a>。打开它，并且选择<code>Main.storyboard</code>文件。我已经为了准备好了一系列组织在一个<code>tab bar controller</code>下<code>view controller</code>。每一个<code>tab</code>包含一个<code>navigation controller</code>。下面的图片强调了示例项目的<code>storyboard</code>部分。</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard1.png" alt="这里写图片描述"></p>
<p>正如你所看到的那样，<code>tab bar controller</code>包含了三个<code>navigation controller</code>。每一个<code>navigation controller</code>控制着不同的视图控制器。现在，想象一下在这个项目里和其他开发者一起工作。正如我前面描述的那样，使用同一个<code>storyboard</code>文件是非常令人头疼的，因为你们每个人都会修改它。你可以把着三个<code>navigation</code>分支分割成三个<code>storyboard</code>文件。然而，当你准备在运行期从一个<code>storyboard</code>跳转到另外一个时，你必须加载相应的<code>storyboard</code>文件。这需要增加额外的代码。</p>
<p><code>xcode 7</code>允许你创建多个<code>storyboards</code>，并且可以方便地操纵它们。选择顶部的<code>navigation controller</code> 以及两个<code>view controller</code>，如下图所示：</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard2.png" alt="这里写图片描述"></p>
<p>选择好之后，打开菜单栏的<code>Editor</code>，然后选择<code>Refactor to Storyboard</code>（如图）</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard3.png" alt="这里写图片描述"></p>
<p>为新的<code>storyboard</code>取一个名字（如图）。我将它命名为<code>First.storyboard</code>。</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard4.png" alt="这里写图片描述"></p>
<p>点击保存。正如你所见到的那样，一个新的<code>storyboard</code>已经被添加到你的项目中了。让我们回到<code>Main.storyboard</code>，你将会看到如下的对象。</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard5.png" alt="这里写图片描述"></p>
<p>这个称之为<code>Storyboard Reference</code>，它确实为新建的<code>First.storyboard</code>的引用，并且替换了先前选择的三个<code>view controller</code>。最棒的是如果你双击<code>storyboard</code>引用，<code>Xcode 7</code>会打开所引用的<code>storyboard</code>。因此，当你想要控制应用流时，你可以方便地导向不同的<code>storyboard</code>。在运行期间，当<code>segue</code>指向的一个<code>Storyboard Reference</code>被执行时，这个被引用的<code>storyboard</code>中的初始化<code>view controller</code>会被加载。此外，<code>Storyboard References</code>还能够引用相同的<code>storyboard</code>。</p>
<p>另外，你也可以手工创建一个新的<code>storyboard</code>，然后添加一个<code>Storyboard Reference</code>到起始的<code>storyboard</code>中。让我们来试一下。</p>
<p>创建一个新的<code>storyboard</code>并命名为<code>Third.storyboard</code>。在<code>Main.storyboard</code>文件中，从<code>Object Library</code>中添加新的<code>Storyboard Reference</code>。选择<code>Storyboard Reference</code>并且打开相应的<code>Attributes Inspector</code>。如下图所示：</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard6.png" alt="这里写图片描述"></p>
<p>在这个字段中，选择你想要引用的<code>storyboard</code>（在我们的例子中是<code>Third</code>）。如果这个字段为空白，则被引用的<code>storyboard</code>是定义的<code>Storyboard Reference</code>。<code>Reference ID</code>指向在目的<code>storyboard</code>中的一个特定<code>scene</code>。如果你置空的话，初始化<code>view controller</code>会加载。最后，<code>Bundle</code>字段需要被置为包含目的<code>storyboard</code>的<code>bundle</code>。如果你留空的话，就会使用源<code>storyboard</code>的<code>bundle</code>。</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard7.png" alt="Storyboard Reference Assignment"></p>
<p>在<code>Third.storyboard</code>文件中，你需要添加一个新的<code>view controller</code>并将其作为初始化的<code>view controller</code>。之后，只要<code>view controller</code>是<code>Main storyboard</code>的一部分，你可以都可以运行<code>app</code>并且导航到那里。</p>
<p>所有，现在你可以在多个文件里组织你的<code>storyboard</code>，并且可以保持这些<code>storyboard</code>的引用。此外，每一个<code>storyboard</code>能够被分配给一个不同的开发者，而你不需要去考虑<code>view controller</code>间的连接组合。这真是非常方便。</p>
<h2 id="Scene-Dock-and-Extra-Views"><a href="#Scene-Dock-and-Extra-Views" class="headerlink" title="Scene Dock and Extra Views"></a>Scene Dock and Extra Views</h2><p>这是我最喜欢的特性。现在，我能够在<code>storyboard</code>中添加在<code>scene</code>体系外的视图。为了让你明白它使如何工作的，我们先创建一个新的项目。将其命名为<code>ExtraView</code>，打开<code>Main storyboard</code>，在顶部的<code>First Responder</code>和<code>Exit</code>之间添加一个新的<code>view</code>。如下图所示（这个叫做<code>Scene Dock</code>）：</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard8.png" alt="这里写图片描述"></p>
<p>把这个<code>view</code>的大小调整为 1500×120 像素。然后在这个<code>view</code>的顶层添加一个大小为 240×112 的小<code>view</code>。把这个视图放到大视图的中心，然后增加顶部和底部的约束 (constants = 8)，宽度约束(constant = 240)  以及水平居中的约束。然后添加一个<code>scrollview</code>到<code>view controller</code>中，将其居中，并添加<code>trailing</code>和<code>leading space</code>约束 (constant = 0)，高度约束(constant=128)，最后增加垂直居中约束。在<code>ViewController.swift</code>中，添加下列两个<code>outlet</code>：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@IBOutlet</span> var <span class="attribute">externalView</span>: UIView!</div><div class="line"><span class="variable">@IBOutlet</span> var <span class="attribute">scrollView</span>: UIScrollView!</div></pre></td></tr></table></figure></p>
<p>将它们连接到<code>scrollview</code>以及外面的<code>view</code>。最后，添加<code>viewDidAppear:</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(animated: Bool)</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidAppear(animated)</div><div class="line">    scrollView.contentSize = externalView.frame.size</div><div class="line">    scrollView.addSubview(externalView)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后运行项目，可以看到的是，你现在可以添加额外的视图（可以任意添加），并且可以在运行期间很方便地加载出来。你可以下载这个<a href="http://www.invasivecode.com/documents/ExtraView.zip" target="_blank" rel="external">示例</a>来加深理解。</p>
<h2 id="定制Transitions"><a href="#定制Transitions" class="headerlink" title="定制Transitions"></a>定制Transitions</h2><p>这是<code>Xcode 7</code>中<code>storyboard</code>另外一个很酷的新特性。具体的细节我将会留到之后发布的文章，这里我只想先给你一些你能做什么的想法。如果你在多<code>storyboard</code>项目中选择任意的<code>action segue</code>，并且打开<code>Attributes Inspector</code>，你将会看到一个新的字段<code>Segue Class</code>，正如下图所示：</p>
<p><img src="http://www.invasivecode.com/blogimages/storyboard/storyboard9.png" alt="这里写图片描述"></p>
<p>你可以创建一个<code>UIStoryboardSegue</code>的子类，然后遵从<code>UIViewControllerTransitioningDelegate</code> 协议。然后，在类中实现<code>animationControllerForPresentedController: presentingController: sourceController:</code> 以及 <code>animationControllerForDismissedController:</code>。此外，你还需要创建两个<code>NSObject</code>的子类，遵从<code>UIViewControllerAnimatedTransitioning delegate</code>。在这些类中，你必须实现两个方法：<code>transitionDuration:</code> 和 <code>animateTransition:</code>。</p>
<p>我将会在接下来的文章中介绍其中的细节。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Xcode 7</code>的<code>Storyboards</code>增加了很多便利的新特性。我们现在可以创建<code>storyboard references</code>，在<code>scene</code>体系外增加视图，并且可以使用新的定制视图过渡。我还讨论了为什么你应该将<code>outlet</code>定义为<code>strong</code>引用而不是<code>weak</code>。</p>
<h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p>Geppy</p>
<p>Geppy Parziale (<a href="http://twitter.com/geppyp" target="_blank" rel="external">@geppyp</a>) is cofounder of InvasiveCode (<a href="http://twitter.com/invasivecode" target="_blank" rel="external">@invasivecode</a>). He has developed iOS applications and <a href="http://ios-training.invasivecode.com/" target="_blank" rel="external">taught iOS development</a> since 2008. He worked at Apple as iOS and OS X Engineer in the Core Recognition team. He has developed several iOS and OS X apps and frameworks for Apple, and many of his development projects are top-grossing iOS apps that are featured in the App Store.</p>
]]></content>
    
    <summary type="html">
    
      Apple 已经对 Xib 和 Storyboard 文件做了很多优化。并且由于这些优化，你现在可以将 IBOutlet 定义为 strong ，替代原来的 weak 。
    
    </summary>
    
      <category term="iOS 9" scheme="http://lin493369.github.io/categories/iOS-9/"/>
    
    
      <category term="storyboard" scheme="http://lin493369.github.io/tags/storyboard/"/>
    
      <category term="strong" scheme="http://lin493369.github.io/tags/strong/"/>
    
      <category term="IB" scheme="http://lin493369.github.io/tags/IB/"/>
    
  </entry>
  
</feed>
